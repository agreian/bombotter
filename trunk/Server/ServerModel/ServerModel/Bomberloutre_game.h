// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Bomberloutre_game.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __C__Users_Florent_Documents_Visual_Studio_2010_Projects_BomberLoutre_Server_ServerModel_ServerModel_Bomberloutre_game_h__
#define __C__Users_Florent_Documents_Visual_Studio_2010_Projects_BomberLoutre_Server_ServerModel_ServerModel_Bomberloutre_game_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <Bomberloutre_map.h>
#include <Bomberloutre_user.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Bomberloutre
{

class GameWaitRoom;

class Game;

class GamesManager;

}

}

namespace Bomberloutre
{

class GameWaitRoom;
bool operator==(const GameWaitRoom&, const GameWaitRoom&);
bool operator<(const GameWaitRoom&, const GameWaitRoom&);

class Game;
bool operator==(const Game&, const Game&);
bool operator<(const Game&, const Game&);

class GamesManager;
bool operator==(const GamesManager&, const GamesManager&);
bool operator<(const GamesManager&, const GamesManager&);

}

namespace IceInternal
{

::Ice::Object* upCast(::Bomberloutre::GameWaitRoom*);
::IceProxy::Ice::Object* upCast(::IceProxy::Bomberloutre::GameWaitRoom*);

::Ice::Object* upCast(::Bomberloutre::Game*);
::IceProxy::Ice::Object* upCast(::IceProxy::Bomberloutre::Game*);

::Ice::Object* upCast(::Bomberloutre::GamesManager*);
::IceProxy::Ice::Object* upCast(::IceProxy::Bomberloutre::GamesManager*);

}

namespace Bomberloutre
{

typedef ::IceInternal::Handle< ::Bomberloutre::GameWaitRoom> GameWaitRoomPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Bomberloutre::GameWaitRoom> GameWaitRoomPrx;

void __read(::IceInternal::BasicStream*, GameWaitRoomPrx&);
void __patch__GameWaitRoomPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Bomberloutre::Game> GamePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Bomberloutre::Game> GamePrx;

void __read(::IceInternal::BasicStream*, GamePrx&);
void __patch__GamePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Bomberloutre::GamesManager> GamesManagerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Bomberloutre::GamesManager> GamesManagerPrx;

void __read(::IceInternal::BasicStream*, GamesManagerPrx&);
void __patch__GamesManagerPtr(void*, ::Ice::ObjectPtr&);

}

namespace Bomberloutre
{

typedef ::std::vector< ::Bomberloutre::GameWaitRoomPrx> RoomList;
void __writeRoomList(::IceInternal::BasicStream*, const ::Bomberloutre::GameWaitRoomPrx*, const ::Bomberloutre::GameWaitRoomPrx*);
void __readRoomList(::IceInternal::BasicStream*, RoomList&);

typedef ::std::vector< ::Bomberloutre::GamePtr> GameList;
void __writeGameList(::IceInternal::BasicStream*, const ::Bomberloutre::GamePtr*, const ::Bomberloutre::GamePtr*);
void __readGameList(::IceInternal::BasicStream*, GameList&);

}

namespace IceAsync
{

}

namespace Bomberloutre
{

class Callback_GameWaitRoom_newUserInRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_newUserInRoom_Base> Callback_GameWaitRoom_newUserInRoomPtr;

class Callback_GameWaitRoom_userLeftRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_userLeftRoom_Base> Callback_GameWaitRoom_userLeftRoomPtr;

class Callback_GameWaitRoom_kickPlayer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_kickPlayer_Base> Callback_GameWaitRoom_kickPlayerPtr;

class Callback_GameWaitRoom_invitePlayer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_invitePlayer_Base> Callback_GameWaitRoom_invitePlayerPtr;

class Callback_GameWaitRoom_userReady_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_userReady_Base> Callback_GameWaitRoom_userReadyPtr;

class Callback_GameWaitRoom_allUsersReady_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_allUsersReady_Base> Callback_GameWaitRoom_allUsersReadyPtr;

class Callback_Game_addBot_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Game_addBot_Base> Callback_Game_addBotPtr;

class Callback_Game_removeBot_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Game_removeBot_Base> Callback_Game_removeBotPtr;

class Callback_Game_createMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Game_createMap_Base> Callback_Game_createMapPtr;

class Callback_Game_startMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Game_startMap_Base> Callback_Game_startMapPtr;

class Callback_Game_endMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Game_endMap_Base> Callback_Game_endMapPtr;

class Callback_GamesManager_getGameList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GamesManager_getGameList_Base> Callback_GamesManager_getGameListPtr;

class Callback_GamesManager_getUserList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GamesManager_getUserList_Base> Callback_GamesManager_getUserListPtr;

class Callback_GamesManager_createGame_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GamesManager_createGame_Base> Callback_GamesManager_createGamePtr;

class Callback_GamesManager_joinGame_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GamesManager_joinGame_Base> Callback_GamesManager_joinGamePtr;

class Callback_GamesManager_removeGame_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GamesManager_removeGame_Base> Callback_GamesManager_removeGamePtr;

}

namespace IceProxy
{

namespace Bomberloutre
{

class GameWaitRoom : virtual public ::IceProxy::Ice::Object
{
public:

    void newUserInRoom(const ::std::string& username)
    {
        newUserInRoom(username, 0);
    }
    void newUserInRoom(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        newUserInRoom(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username)
    {
        return begin_newUserInRoom(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_newUserInRoom(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newUserInRoom(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newUserInRoom(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Bomberloutre::Callback_GameWaitRoom_newUserInRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newUserInRoom(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_newUserInRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newUserInRoom(username, &__ctx, __del, __cookie);
    }

    void end_newUserInRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void newUserInRoom(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void userLeftRoom(const ::std::string& username)
    {
        userLeftRoom(username, 0);
    }
    void userLeftRoom(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        userLeftRoom(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username)
    {
        return begin_userLeftRoom(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_userLeftRoom(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userLeftRoom(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userLeftRoom(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Bomberloutre::Callback_GameWaitRoom_userLeftRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userLeftRoom(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_userLeftRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userLeftRoom(username, &__ctx, __del, __cookie);
    }

    void end_userLeftRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void userLeftRoom(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void kickPlayer(const ::std::string& username)
    {
        kickPlayer(username, 0);
    }
    void kickPlayer(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        kickPlayer(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username)
    {
        return begin_kickPlayer(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_kickPlayer(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickPlayer(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickPlayer(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Bomberloutre::Callback_GameWaitRoom_kickPlayerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickPlayer(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_kickPlayerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickPlayer(username, &__ctx, __del, __cookie);
    }

    void end_kickPlayer(const ::Ice::AsyncResultPtr&);
    
private:

    void kickPlayer(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void invitePlayer(const ::std::string& username)
    {
        invitePlayer(username, 0);
    }
    void invitePlayer(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        invitePlayer(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username)
    {
        return begin_invitePlayer(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_invitePlayer(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitePlayer(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitePlayer(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Bomberloutre::Callback_GameWaitRoom_invitePlayerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitePlayer(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_invitePlayerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitePlayer(username, &__ctx, __del, __cookie);
    }

    void end_invitePlayer(const ::Ice::AsyncResultPtr&);
    
private:

    void invitePlayer(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void userReady(const ::std::string& username)
    {
        userReady(username, 0);
    }
    void userReady(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        userReady(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username)
    {
        return begin_userReady(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_userReady(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userReady(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userReady(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Bomberloutre::Callback_GameWaitRoom_userReadyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userReady(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_userReadyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userReady(username, &__ctx, __del, __cookie);
    }

    void end_userReady(const ::Ice::AsyncResultPtr&);
    
private:

    void userReady(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_userReady(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void allUsersReady()
    {
        allUsersReady(0);
    }
    void allUsersReady(const ::Ice::Context& __ctx)
    {
        allUsersReady(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady()
    {
        return begin_allUsersReady(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::Context& __ctx)
    {
        return begin_allUsersReady(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allUsersReady(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allUsersReady(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Bomberloutre::Callback_GameWaitRoom_allUsersReadyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allUsersReady(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_allUsersReadyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allUsersReady(&__ctx, __del, __cookie);
    }

    void end_allUsersReady(const ::Ice::AsyncResultPtr&);
    
private:

    void allUsersReady(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Game : virtual public ::IceProxy::Ice::Object
{
public:

    void addBot()
    {
        addBot(0);
    }
    void addBot(const ::Ice::Context& __ctx)
    {
        addBot(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_addBot()
    {
        return begin_addBot(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::Context& __ctx)
    {
        return begin_addBot(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addBot(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addBot(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Bomberloutre::Callback_Game_addBotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addBot(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_Game_addBotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addBot(&__ctx, __del, __cookie);
    }

    void end_addBot(const ::Ice::AsyncResultPtr&);
    
private:

    void addBot(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeBot()
    {
        removeBot(0);
    }
    void removeBot(const ::Ice::Context& __ctx)
    {
        removeBot(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeBot()
    {
        return begin_removeBot(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::Context& __ctx)
    {
        return begin_removeBot(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeBot(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeBot(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Bomberloutre::Callback_Game_removeBotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeBot(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_Game_removeBotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeBot(&__ctx, __del, __cookie);
    }

    void end_removeBot(const ::Ice::AsyncResultPtr&);
    
private:

    void removeBot(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool createMap(const ::std::string& mode, const ::std::string& mapSkin)
    {
        return createMap(mode, mapSkin, 0);
    }
    bool createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context& __ctx)
    {
        return createMap(mode, mapSkin, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin)
    {
        return begin_createMap(mode, mapSkin, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context& __ctx)
    {
        return begin_createMap(mode, mapSkin, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createMap(mode, mapSkin, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createMap(mode, mapSkin, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Bomberloutre::Callback_Game_createMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createMap(mode, mapSkin, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_Game_createMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createMap(mode, mapSkin, &__ctx, __del, __cookie);
    }

    bool end_createMap(const ::Ice::AsyncResultPtr&);
    
private:

    bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void startMap()
    {
        startMap(0);
    }
    void startMap(const ::Ice::Context& __ctx)
    {
        startMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_startMap()
    {
        return begin_startMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::Context& __ctx)
    {
        return begin_startMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Bomberloutre::Callback_Game_startMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_Game_startMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startMap(&__ctx, __del, __cookie);
    }

    void end_startMap(const ::Ice::AsyncResultPtr&);
    
private:

    void startMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void endMap()
    {
        endMap(0);
    }
    void endMap(const ::Ice::Context& __ctx)
    {
        endMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_endMap()
    {
        return begin_endMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::Context& __ctx)
    {
        return begin_endMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_endMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_endMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Bomberloutre::Callback_Game_endMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_endMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_Game_endMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_endMap(&__ctx, __del, __cookie);
    }

    void end_endMap(const ::Ice::AsyncResultPtr&);
    
private:

    void endMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Game> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<Game> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<Game*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<Game*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class GamesManager : virtual public ::IceProxy::Ice::Object
{
public:

    ::Bomberloutre::GameList getGameList()
    {
        return getGameList(0);
    }
    ::Bomberloutre::GameList getGameList(const ::Ice::Context& __ctx)
    {
        return getGameList(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getGameList()
    {
        return begin_getGameList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::Context& __ctx)
    {
        return begin_getGameList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGameList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGameList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Bomberloutre::Callback_GamesManager_getGameListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGameList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GamesManager_getGameListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGameList(&__ctx, __del, __cookie);
    }

    ::Bomberloutre::GameList end_getGameList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::GameList getGameList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Bomberloutre::UserList getUserList()
    {
        return getUserList(0);
    }
    ::Bomberloutre::UserList getUserList(const ::Ice::Context& __ctx)
    {
        return getUserList(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUserList()
    {
        return begin_getUserList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::Context& __ctx)
    {
        return begin_getUserList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Bomberloutre::Callback_GamesManager_getUserListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GamesManager_getUserListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserList(&__ctx, __del, __cookie);
    }

    ::Bomberloutre::UserList end_getUserList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::UserList getUserList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Bomberloutre::GamePtr createGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room)
    {
        return createGame(name, room, 0);
    }
    ::Bomberloutre::GamePtr createGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Ice::Context& __ctx)
    {
        return createGame(name, room, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room)
    {
        return begin_createGame(name, room, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Ice::Context& __ctx)
    {
        return begin_createGame(name, room, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createGame(name, room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createGame(name, room, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::Callback_GamesManager_createGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createGame(name, room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GamesManager_createGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createGame(name, room, &__ctx, __del, __cookie);
    }

    ::Bomberloutre::GamePtr end_createGame(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::GamePtr createGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo)
    {
        return joinGame(name, room, mo, 0);
    }
    bool joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx)
    {
        return joinGame(name, room, mo, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo)
    {
        return begin_joinGame(name, room, mo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx)
    {
        return begin_joinGame(name, room, mo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinGame(name, room, mo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinGame(name, room, mo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Bomberloutre::Callback_GamesManager_joinGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinGame(name, room, mo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GamesManager_joinGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinGame(name, room, mo, &__ctx, __del, __cookie);
    }

    bool end_joinGame(const ::Ice::AsyncResultPtr&);
    
private:

    bool joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool removeGame(const ::std::string& name)
    {
        return removeGame(name, 0);
    }
    bool removeGame(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return removeGame(name, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::std::string& name)
    {
        return begin_removeGame(name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return begin_removeGame(name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::std::string& name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGame(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::std::string& name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGame(name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::std::string& name, const ::Bomberloutre::Callback_GamesManager_removeGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGame(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::std::string& name, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GamesManager_removeGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGame(name, &__ctx, __del, __cookie);
    }

    bool end_removeGame(const ::Ice::AsyncResultPtr&);
    
private:

    bool removeGame(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeGame(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<GamesManager> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GamesManager> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GamesManager*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<GamesManager*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Bomberloutre
{

class GameWaitRoom : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void newUserInRoom(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void userLeftRoom(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void kickPlayer(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void invitePlayer(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void userReady(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void allUsersReady(const ::Ice::Context*) = 0;
};

class Game : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void addBot(const ::Ice::Context*) = 0;

    virtual void removeBot(const ::Ice::Context*) = 0;

    virtual bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void startMap(const ::Ice::Context*) = 0;

    virtual void endMap(const ::Ice::Context*) = 0;
};

class GamesManager : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Bomberloutre::GameList getGameList(const ::Ice::Context*) = 0;

    virtual ::Bomberloutre::UserList getUserList(const ::Ice::Context*) = 0;

    virtual ::Bomberloutre::GamePtr createGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Ice::Context*) = 0;

    virtual bool joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*) = 0;

    virtual bool removeGame(const ::std::string&, const ::Ice::Context*) = 0;
};

}

}

namespace IceDelegateM
{

namespace Bomberloutre
{

class GameWaitRoom : virtual public ::IceDelegate::Bomberloutre::GameWaitRoom,
                     virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void newUserInRoom(const ::std::string&, const ::Ice::Context*);

    virtual void userLeftRoom(const ::std::string&, const ::Ice::Context*);

    virtual void kickPlayer(const ::std::string&, const ::Ice::Context*);

    virtual void invitePlayer(const ::std::string&, const ::Ice::Context*);

    virtual void userReady(const ::std::string&, const ::Ice::Context*);

    virtual void allUsersReady(const ::Ice::Context*);
};

class Game : virtual public ::IceDelegate::Bomberloutre::Game,
             virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void addBot(const ::Ice::Context*);

    virtual void removeBot(const ::Ice::Context*);

    virtual bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void startMap(const ::Ice::Context*);

    virtual void endMap(const ::Ice::Context*);
};

class GamesManager : virtual public ::IceDelegate::Bomberloutre::GamesManager,
                     virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Bomberloutre::GameList getGameList(const ::Ice::Context*);

    virtual ::Bomberloutre::UserList getUserList(const ::Ice::Context*);

    virtual ::Bomberloutre::GamePtr createGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Ice::Context*);

    virtual bool joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);

    virtual bool removeGame(const ::std::string&, const ::Ice::Context*);
};

}

}

namespace IceDelegateD
{

namespace Bomberloutre
{

class GameWaitRoom : virtual public ::IceDelegate::Bomberloutre::GameWaitRoom,
                     virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void newUserInRoom(const ::std::string&, const ::Ice::Context*);

    virtual void userLeftRoom(const ::std::string&, const ::Ice::Context*);

    virtual void kickPlayer(const ::std::string&, const ::Ice::Context*);

    virtual void invitePlayer(const ::std::string&, const ::Ice::Context*);

    virtual void userReady(const ::std::string&, const ::Ice::Context*);

    virtual void allUsersReady(const ::Ice::Context*);
};

class Game : virtual public ::IceDelegate::Bomberloutre::Game,
             virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void addBot(const ::Ice::Context*);

    virtual void removeBot(const ::Ice::Context*);

    virtual bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void startMap(const ::Ice::Context*);

    virtual void endMap(const ::Ice::Context*);
};

class GamesManager : virtual public ::IceDelegate::Bomberloutre::GamesManager,
                     virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Bomberloutre::GameList getGameList(const ::Ice::Context*);

    virtual ::Bomberloutre::UserList getUserList(const ::Ice::Context*);

    virtual ::Bomberloutre::GamePtr createGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Ice::Context*);

    virtual bool joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);

    virtual bool removeGame(const ::std::string&, const ::Ice::Context*);
};

}

}

namespace Bomberloutre
{

class GameWaitRoom : virtual public ::Ice::Object
{
public:

    typedef GameWaitRoomPrx ProxyType;
    typedef GameWaitRoomPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void newUserInRoom(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___newUserInRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void userLeftRoom(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___userLeftRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void kickPlayer(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___kickPlayer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void invitePlayer(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___invitePlayer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void userReady(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___userReady(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void allUsersReady(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___allUsersReady(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const GameWaitRoom& l, const GameWaitRoom& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const GameWaitRoom& l, const GameWaitRoom& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Game : virtual public ::Ice::Object, private IceInternal::GCShared
{
public:

    typedef GamePrx ProxyType;
    typedef GamePtr PointerType;
    
    Game() {}
    Game(const ::std::string&, ::Ice::Int, ::Ice::Int, const ::Bomberloutre::RoomList&, const ::Bomberloutre::MapPtr&);
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesClasses();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    virtual void addBot(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addBot(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeBot(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeBot(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void startMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___startMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void endMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___endMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif

    ::std::string name;

    ::Ice::Int state;

    ::Ice::Int nbRound;

    ::Bomberloutre::RoomList rooms;

    ::Bomberloutre::MapPtr currentMap;
};

inline bool operator==(const Game& l, const Game& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Game& l, const Game& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class GamesManager : virtual public ::Ice::Object
{
public:

    typedef GamesManagerPrx ProxyType;
    typedef GamesManagerPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Bomberloutre::GameList getGameList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getGameList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Bomberloutre::UserList getUserList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUserList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Bomberloutre::GamePtr createGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createGame(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___joinGame(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool removeGame(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeGame(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const GamesManager& l, const GamesManager& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const GamesManager& l, const GamesManager& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Bomberloutre
{

template<class T>
class CallbackNC_GameWaitRoom_newUserInRoom : public Callback_GameWaitRoom_newUserInRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_newUserInRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_newUserInRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_newUserInRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_newUserInRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_newUserInRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_newUserInRoom : public Callback_GameWaitRoom_newUserInRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_newUserInRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_newUserInRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_newUserInRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_newUserInRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_newUserInRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_userLeftRoom : public Callback_GameWaitRoom_userLeftRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_userLeftRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userLeftRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userLeftRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userLeftRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userLeftRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_userLeftRoom : public Callback_GameWaitRoom_userLeftRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_userLeftRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userLeftRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userLeftRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userLeftRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userLeftRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_kickPlayer : public Callback_GameWaitRoom_kickPlayer_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_kickPlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_kickPlayerPtr
newCallback_GameWaitRoom_kickPlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_kickPlayer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_kickPlayerPtr
newCallback_GameWaitRoom_kickPlayer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_kickPlayer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_kickPlayerPtr
newCallback_GameWaitRoom_kickPlayer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_kickPlayer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_kickPlayerPtr
newCallback_GameWaitRoom_kickPlayer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_kickPlayer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_kickPlayer : public Callback_GameWaitRoom_kickPlayer_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_kickPlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_kickPlayerPtr
newCallback_GameWaitRoom_kickPlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_kickPlayer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_kickPlayerPtr
newCallback_GameWaitRoom_kickPlayer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_kickPlayer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_kickPlayerPtr
newCallback_GameWaitRoom_kickPlayer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_kickPlayer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_kickPlayerPtr
newCallback_GameWaitRoom_kickPlayer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_kickPlayer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_invitePlayer : public Callback_GameWaitRoom_invitePlayer_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_invitePlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_invitePlayerPtr
newCallback_GameWaitRoom_invitePlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_invitePlayer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_invitePlayerPtr
newCallback_GameWaitRoom_invitePlayer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_invitePlayer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_invitePlayerPtr
newCallback_GameWaitRoom_invitePlayer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_invitePlayer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_invitePlayerPtr
newCallback_GameWaitRoom_invitePlayer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_invitePlayer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_invitePlayer : public Callback_GameWaitRoom_invitePlayer_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_invitePlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_invitePlayerPtr
newCallback_GameWaitRoom_invitePlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_invitePlayer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_invitePlayerPtr
newCallback_GameWaitRoom_invitePlayer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_invitePlayer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_invitePlayerPtr
newCallback_GameWaitRoom_invitePlayer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_invitePlayer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_invitePlayerPtr
newCallback_GameWaitRoom_invitePlayer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_invitePlayer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_userReady : public Callback_GameWaitRoom_userReady_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_userReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userReady<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userReady<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userReady<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userReady<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_userReady : public Callback_GameWaitRoom_userReady_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_userReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userReady<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userReady<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userReady<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userReady<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_allUsersReady : public Callback_GameWaitRoom_allUsersReady_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_allUsersReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_allUsersReady<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_allUsersReady<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_allUsersReady<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_allUsersReady<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_allUsersReady : public Callback_GameWaitRoom_allUsersReady_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_allUsersReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_allUsersReady<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_allUsersReady<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_allUsersReady<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_allUsersReady<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Game_addBot : public Callback_Game_addBot_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Game_addBot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Game_addBotPtr
newCallback_Game_addBot(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_addBot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_addBotPtr
newCallback_Game_addBot(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_addBot<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Game_addBotPtr
newCallback_Game_addBot(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_addBot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_addBotPtr
newCallback_Game_addBot(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_addBot<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Game_addBot : public Callback_Game_addBot_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Game_addBot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Game_addBotPtr
newCallback_Game_addBot(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_addBot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_addBotPtr
newCallback_Game_addBot(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_addBot<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Game_addBotPtr
newCallback_Game_addBot(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_addBot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_addBotPtr
newCallback_Game_addBot(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_addBot<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Game_removeBot : public Callback_Game_removeBot_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Game_removeBot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Game_removeBotPtr
newCallback_Game_removeBot(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_removeBot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_removeBotPtr
newCallback_Game_removeBot(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_removeBot<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Game_removeBotPtr
newCallback_Game_removeBot(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_removeBot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_removeBotPtr
newCallback_Game_removeBot(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_removeBot<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Game_removeBot : public Callback_Game_removeBot_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Game_removeBot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Game_removeBotPtr
newCallback_Game_removeBot(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_removeBot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_removeBotPtr
newCallback_Game_removeBot(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_removeBot<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Game_removeBotPtr
newCallback_Game_removeBot(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_removeBot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_removeBotPtr
newCallback_Game_removeBot(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_removeBot<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Game_createMap : public Callback_Game_createMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Game_createMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamePrx __proxy = ::Bomberloutre::GamePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_createMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_Game_createMapPtr
newCallback_Game_createMap(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_createMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_createMapPtr
newCallback_Game_createMap(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_createMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Game_createMap : public Callback_Game_createMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Game_createMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamePrx __proxy = ::Bomberloutre::GamePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_createMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_Game_createMapPtr
newCallback_Game_createMap(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_createMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_createMapPtr
newCallback_Game_createMap(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_createMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Game_startMap : public Callback_Game_startMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Game_startMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Game_startMapPtr
newCallback_Game_startMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_startMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_startMapPtr
newCallback_Game_startMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_startMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Game_startMapPtr
newCallback_Game_startMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_startMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_startMapPtr
newCallback_Game_startMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_startMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Game_startMap : public Callback_Game_startMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Game_startMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Game_startMapPtr
newCallback_Game_startMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_startMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_startMapPtr
newCallback_Game_startMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_startMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Game_startMapPtr
newCallback_Game_startMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_startMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_startMapPtr
newCallback_Game_startMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_startMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Game_endMap : public Callback_Game_endMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Game_endMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Game_endMapPtr
newCallback_Game_endMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_endMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_endMapPtr
newCallback_Game_endMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_endMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Game_endMapPtr
newCallback_Game_endMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_endMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Game_endMapPtr
newCallback_Game_endMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Game_endMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Game_endMap : public Callback_Game_endMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Game_endMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Game_endMapPtr
newCallback_Game_endMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_endMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_endMapPtr
newCallback_Game_endMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_endMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Game_endMapPtr
newCallback_Game_endMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_endMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Game_endMapPtr
newCallback_Game_endMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Game_endMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GamesManager_getGameList : public Callback_GamesManager_getGameList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::GameList&);

    CallbackNC_GamesManager_getGameList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::GameList __ret;
        try
        {
            __ret = __proxy->end_getGameList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GamesManager_getGameListPtr
newCallback_GamesManager_getGameList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::GameList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_getGameList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GamesManager_getGameListPtr
newCallback_GamesManager_getGameList(T* instance, void (T::*cb)(const ::Bomberloutre::GameList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_getGameList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GamesManager_getGameList : public Callback_GamesManager_getGameList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::GameList&, const CT&);

    Callback_GamesManager_getGameList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::GameList __ret;
        try
        {
            __ret = __proxy->end_getGameList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GamesManager_getGameListPtr
newCallback_GamesManager_getGameList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::GameList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_getGameList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GamesManager_getGameListPtr
newCallback_GamesManager_getGameList(T* instance, void (T::*cb)(const ::Bomberloutre::GameList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_getGameList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GamesManager_getUserList : public Callback_GamesManager_getUserList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::UserList&);

    CallbackNC_GamesManager_getUserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::UserList __ret;
        try
        {
            __ret = __proxy->end_getUserList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GamesManager_getUserListPtr
newCallback_GamesManager_getUserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::UserList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_getUserList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GamesManager_getUserListPtr
newCallback_GamesManager_getUserList(T* instance, void (T::*cb)(const ::Bomberloutre::UserList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_getUserList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GamesManager_getUserList : public Callback_GamesManager_getUserList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::UserList&, const CT&);

    Callback_GamesManager_getUserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::UserList __ret;
        try
        {
            __ret = __proxy->end_getUserList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GamesManager_getUserListPtr
newCallback_GamesManager_getUserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::UserList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_getUserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GamesManager_getUserListPtr
newCallback_GamesManager_getUserList(T* instance, void (T::*cb)(const ::Bomberloutre::UserList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_getUserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GamesManager_createGame : public Callback_GamesManager_createGame_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::GamePtr&);

    CallbackNC_GamesManager_createGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::GamePtr __ret;
        try
        {
            __ret = __proxy->end_createGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GamesManager_createGamePtr
newCallback_GamesManager_createGame(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::GamePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_createGame<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GamesManager_createGamePtr
newCallback_GamesManager_createGame(T* instance, void (T::*cb)(const ::Bomberloutre::GamePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_createGame<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GamesManager_createGame : public Callback_GamesManager_createGame_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::GamePtr&, const CT&);

    Callback_GamesManager_createGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::GamePtr __ret;
        try
        {
            __ret = __proxy->end_createGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GamesManager_createGamePtr
newCallback_GamesManager_createGame(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::GamePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_createGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GamesManager_createGamePtr
newCallback_GamesManager_createGame(T* instance, void (T::*cb)(const ::Bomberloutre::GamePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_createGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GamesManager_joinGame : public Callback_GamesManager_joinGame_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_GamesManager_joinGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_joinGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GamesManager_joinGamePtr
newCallback_GamesManager_joinGame(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_joinGame<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GamesManager_joinGamePtr
newCallback_GamesManager_joinGame(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_joinGame<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GamesManager_joinGame : public Callback_GamesManager_joinGame_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_GamesManager_joinGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_joinGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GamesManager_joinGamePtr
newCallback_GamesManager_joinGame(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_joinGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GamesManager_joinGamePtr
newCallback_GamesManager_joinGame(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_joinGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GamesManager_removeGame : public Callback_GamesManager_removeGame_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_GamesManager_removeGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_removeGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GamesManager_removeGamePtr
newCallback_GamesManager_removeGame(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_removeGame<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GamesManager_removeGamePtr
newCallback_GamesManager_removeGame(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GamesManager_removeGame<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GamesManager_removeGame : public Callback_GamesManager_removeGame_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_GamesManager_removeGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GamesManagerPrx __proxy = ::Bomberloutre::GamesManagerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_removeGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GamesManager_removeGamePtr
newCallback_GamesManager_removeGame(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_removeGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GamesManager_removeGamePtr
newCallback_GamesManager_removeGame(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GamesManager_removeGame<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
