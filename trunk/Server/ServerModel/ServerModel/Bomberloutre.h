// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Bomberloutre.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __C__Users_Florent_Documents_Visual_Studio_2010_Projects_BomberLoutre_Server_ServerModel_ServerModel_Bomberloutre_h__
#define __C__Users_Florent_Documents_Visual_Studio_2010_Projects_BomberLoutre_Server_ServerModel_ServerModel_Bomberloutre_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <Bomberloutre_map_item.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Bomberloutre
{

class GameInterface;

class GameWaitRoom;

class MapInterface;

class MapObserver;

class ServerInterface;

}

}

namespace Bomberloutre
{

class GameInterface;
bool operator==(const GameInterface&, const GameInterface&);
bool operator<(const GameInterface&, const GameInterface&);

class GameWaitRoom;
bool operator==(const GameWaitRoom&, const GameWaitRoom&);
bool operator<(const GameWaitRoom&, const GameWaitRoom&);

class MapInterface;
bool operator==(const MapInterface&, const MapInterface&);
bool operator<(const MapInterface&, const MapInterface&);

class MapObserver;
bool operator==(const MapObserver&, const MapObserver&);
bool operator<(const MapObserver&, const MapObserver&);

class ServerInterface;
bool operator==(const ServerInterface&, const ServerInterface&);
bool operator<(const ServerInterface&, const ServerInterface&);

}

namespace IceInternal
{

::Ice::Object* upCast(::Bomberloutre::GameInterface*);
::IceProxy::Ice::Object* upCast(::IceProxy::Bomberloutre::GameInterface*);

::Ice::Object* upCast(::Bomberloutre::GameWaitRoom*);
::IceProxy::Ice::Object* upCast(::IceProxy::Bomberloutre::GameWaitRoom*);

::Ice::Object* upCast(::Bomberloutre::MapInterface*);
::IceProxy::Ice::Object* upCast(::IceProxy::Bomberloutre::MapInterface*);

::Ice::Object* upCast(::Bomberloutre::MapObserver*);
::IceProxy::Ice::Object* upCast(::IceProxy::Bomberloutre::MapObserver*);

::Ice::Object* upCast(::Bomberloutre::ServerInterface*);
::IceProxy::Ice::Object* upCast(::IceProxy::Bomberloutre::ServerInterface*);

}

namespace Bomberloutre
{

typedef ::IceInternal::Handle< ::Bomberloutre::GameInterface> GameInterfacePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Bomberloutre::GameInterface> GameInterfacePrx;

void __read(::IceInternal::BasicStream*, GameInterfacePrx&);
void __patch__GameInterfacePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Bomberloutre::GameWaitRoom> GameWaitRoomPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Bomberloutre::GameWaitRoom> GameWaitRoomPrx;

void __read(::IceInternal::BasicStream*, GameWaitRoomPrx&);
void __patch__GameWaitRoomPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Bomberloutre::MapInterface> MapInterfacePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Bomberloutre::MapInterface> MapInterfacePrx;

void __read(::IceInternal::BasicStream*, MapInterfacePrx&);
void __patch__MapInterfacePtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Bomberloutre::MapObserver> MapObserverPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Bomberloutre::MapObserver> MapObserverPrx;

void __read(::IceInternal::BasicStream*, MapObserverPrx&);
void __patch__MapObserverPtr(void*, ::Ice::ObjectPtr&);

typedef ::IceInternal::Handle< ::Bomberloutre::ServerInterface> ServerInterfacePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Bomberloutre::ServerInterface> ServerInterfacePrx;

void __read(::IceInternal::BasicStream*, ServerInterfacePrx&);
void __patch__ServerInterfacePtr(void*, ::Ice::ObjectPtr&);

}

namespace Bomberloutre
{

struct UserData
{
    ::std::string gameTag;
    ::Ice::Int gameCount;
    ::Ice::Int winCount;
    ::Ice::Int drawCount;
    ::Ice::Int killCount;
    ::Ice::Int deathCount;
    ::Ice::Int suicideCount;

    bool operator==(const UserData& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(gameTag != __rhs.gameTag)
        {
            return false;
        }
        if(gameCount != __rhs.gameCount)
        {
            return false;
        }
        if(winCount != __rhs.winCount)
        {
            return false;
        }
        if(drawCount != __rhs.drawCount)
        {
            return false;
        }
        if(killCount != __rhs.killCount)
        {
            return false;
        }
        if(deathCount != __rhs.deathCount)
        {
            return false;
        }
        if(suicideCount != __rhs.suicideCount)
        {
            return false;
        }
        return true;
    }

    bool operator<(const UserData& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(gameTag < __rhs.gameTag)
        {
            return true;
        }
        else if(__rhs.gameTag < gameTag)
        {
            return false;
        }
        if(gameCount < __rhs.gameCount)
        {
            return true;
        }
        else if(__rhs.gameCount < gameCount)
        {
            return false;
        }
        if(winCount < __rhs.winCount)
        {
            return true;
        }
        else if(__rhs.winCount < winCount)
        {
            return false;
        }
        if(drawCount < __rhs.drawCount)
        {
            return true;
        }
        else if(__rhs.drawCount < drawCount)
        {
            return false;
        }
        if(killCount < __rhs.killCount)
        {
            return true;
        }
        else if(__rhs.killCount < killCount)
        {
            return false;
        }
        if(deathCount < __rhs.deathCount)
        {
            return true;
        }
        else if(__rhs.deathCount < deathCount)
        {
            return false;
        }
        if(suicideCount < __rhs.suicideCount)
        {
            return true;
        }
        else if(__rhs.suicideCount < suicideCount)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const UserData& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const UserData& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const UserData& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const UserData& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Bomberloutre::UserData> UserDataList;
void __writeUserDataList(::IceInternal::BasicStream*, const ::Bomberloutre::UserData*, const ::Bomberloutre::UserData*);
void __readUserDataList(::IceInternal::BasicStream*, UserDataList&);

struct GameData
{
    ::std::string name;
    ::Ice::Int roundCount;
    ::Ice::Int state;
    ::Ice::Int playerCount;

    bool operator==(const GameData& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(roundCount != __rhs.roundCount)
        {
            return false;
        }
        if(state != __rhs.state)
        {
            return false;
        }
        if(playerCount != __rhs.playerCount)
        {
            return false;
        }
        return true;
    }

    bool operator<(const GameData& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(roundCount < __rhs.roundCount)
        {
            return true;
        }
        else if(__rhs.roundCount < roundCount)
        {
            return false;
        }
        if(state < __rhs.state)
        {
            return true;
        }
        else if(__rhs.state < state)
        {
            return false;
        }
        if(playerCount < __rhs.playerCount)
        {
            return true;
        }
        else if(__rhs.playerCount < playerCount)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const GameData& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const GameData& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const GameData& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const GameData& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Bomberloutre::GameData> GameDataList;
void __writeGameDataList(::IceInternal::BasicStream*, const ::Bomberloutre::GameData*, const ::Bomberloutre::GameData*);
void __readGameDataList(::IceInternal::BasicStream*, GameDataList&);

struct Player
{
    ::Ice::Int posX;
    ::Ice::Int posY;
    ::Ice::Int width;
    ::Ice::Int height;
    ::Ice::Int killCount;
    ::Ice::Int deathCount;
    ::Ice::Int suicideCount;
    ::Bomberloutre::UserData related;

    bool operator==(const Player& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(posX != __rhs.posX)
        {
            return false;
        }
        if(posY != __rhs.posY)
        {
            return false;
        }
        if(width != __rhs.width)
        {
            return false;
        }
        if(height != __rhs.height)
        {
            return false;
        }
        if(killCount != __rhs.killCount)
        {
            return false;
        }
        if(deathCount != __rhs.deathCount)
        {
            return false;
        }
        if(suicideCount != __rhs.suicideCount)
        {
            return false;
        }
        if(related != __rhs.related)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Player& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(posX < __rhs.posX)
        {
            return true;
        }
        else if(__rhs.posX < posX)
        {
            return false;
        }
        if(posY < __rhs.posY)
        {
            return true;
        }
        else if(__rhs.posY < posY)
        {
            return false;
        }
        if(width < __rhs.width)
        {
            return true;
        }
        else if(__rhs.width < width)
        {
            return false;
        }
        if(height < __rhs.height)
        {
            return true;
        }
        else if(__rhs.height < height)
        {
            return false;
        }
        if(killCount < __rhs.killCount)
        {
            return true;
        }
        else if(__rhs.killCount < killCount)
        {
            return false;
        }
        if(deathCount < __rhs.deathCount)
        {
            return true;
        }
        else if(__rhs.deathCount < deathCount)
        {
            return false;
        }
        if(suicideCount < __rhs.suicideCount)
        {
            return true;
        }
        else if(__rhs.suicideCount < suicideCount)
        {
            return false;
        }
        if(related < __rhs.related)
        {
            return true;
        }
        else if(__rhs.related < related)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Player& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Player& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Player& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Player& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Bomberloutre::Player> PlayerList;
void __writePlayerList(::IceInternal::BasicStream*, const ::Bomberloutre::Player*, const ::Bomberloutre::Player*);
void __readPlayerList(::IceInternal::BasicStream*, PlayerList&);

struct Point
{
    ::Ice::Int x;
    ::Ice::Int y;

    bool operator==(const Point& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(x != __rhs.x)
        {
            return false;
        }
        if(y != __rhs.y)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Point& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(x < __rhs.x)
        {
            return true;
        }
        else if(__rhs.x < x)
        {
            return false;
        }
        if(y < __rhs.y)
        {
            return true;
        }
        else if(__rhs.y < y)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Point& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Point& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Point& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Point& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct Map
{
    ::Bomberloutre::MapInterfacePrx mi;
    ::Bomberloutre::MapItems items;
    ::Bomberloutre::PlayerList players;

    bool operator==(const Map& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(mi != __rhs.mi)
        {
            return false;
        }
        if(items != __rhs.items)
        {
            return false;
        }
        if(players != __rhs.players)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Map& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(mi < __rhs.mi)
        {
            return true;
        }
        else if(__rhs.mi < mi)
        {
            return false;
        }
        if(items < __rhs.items)
        {
            return true;
        }
        else if(__rhs.items < items)
        {
            return false;
        }
        if(players < __rhs.players)
        {
            return true;
        }
        else if(__rhs.players < players)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Map& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Map& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Map& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Map& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

class UserException : public ::Ice::UserException
{
public:

    UserException() {}
    explicit UserException(const ::std::string&);
    virtual ~UserException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    ::std::string reason;

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

static UserException __UserException_init;

class BadLoginException : public ::Bomberloutre::UserException
{
public:

    BadLoginException() {}
    explicit BadLoginException(const ::std::string&);
    virtual ~BadLoginException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class BadPasswordException : public ::Bomberloutre::UserException
{
public:

    BadPasswordException() {}
    explicit BadPasswordException(const ::std::string&);
    virtual ~BadPasswordException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

class UserAlreadyExistsException : public ::Bomberloutre::UserException
{
public:

    UserAlreadyExistsException() {}
    explicit UserAlreadyExistsException(const ::std::string&);
    virtual ~UserAlreadyExistsException() throw();

    virtual ::std::string ice_name() const;
    virtual ::Ice::Exception* ice_clone() const;
    virtual void ice_throw() const;

    static const ::IceInternal::UserExceptionFactoryPtr& ice_factory();

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

}

namespace Bomberloutre
{

class Callback_GameInterface_getName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_getName_Base> Callback_GameInterface_getNamePtr;

class Callback_GameInterface_getState_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_getState_Base> Callback_GameInterface_getStatePtr;

class Callback_GameInterface_getRoundCount_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_getRoundCount_Base> Callback_GameInterface_getRoundCountPtr;

class Callback_GameInterface_setName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_setName_Base> Callback_GameInterface_setNamePtr;

class Callback_GameInterface_setState_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_setState_Base> Callback_GameInterface_setStatePtr;

class Callback_GameInterface_setRoundCount_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_setRoundCount_Base> Callback_GameInterface_setRoundCountPtr;

class Callback_GameInterface_kickPlayer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_kickPlayer_Base> Callback_GameInterface_kickPlayerPtr;

class Callback_GameInterface_invitePlayer_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_invitePlayer_Base> Callback_GameInterface_invitePlayerPtr;

class Callback_GameInterface_addBot_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_addBot_Base> Callback_GameInterface_addBotPtr;

class Callback_GameInterface_removeBot_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_removeBot_Base> Callback_GameInterface_removeBotPtr;

class Callback_GameInterface_createMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_createMap_Base> Callback_GameInterface_createMapPtr;

class Callback_GameInterface_startMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_startMap_Base> Callback_GameInterface_startMapPtr;

class Callback_GameInterface_endMap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_endMap_Base> Callback_GameInterface_endMapPtr;

class Callback_GameInterface_removeGame_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameInterface_removeGame_Base> Callback_GameInterface_removeGamePtr;

class Callback_GameWaitRoom_newUserInRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_newUserInRoom_Base> Callback_GameWaitRoom_newUserInRoomPtr;

class Callback_GameWaitRoom_userLeftRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_userLeftRoom_Base> Callback_GameWaitRoom_userLeftRoomPtr;

class Callback_GameWaitRoom_allUsersReady_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_allUsersReady_Base> Callback_GameWaitRoom_allUsersReadyPtr;

class Callback_GameWaitRoom_userReady_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_userReady_Base> Callback_GameWaitRoom_userReadyPtr;

class Callback_GameWaitRoom_gameStart_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_gameStart_Base> Callback_GameWaitRoom_gameStartPtr;

class Callback_GameWaitRoom_gameEnd_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GameWaitRoom_gameEnd_Base> Callback_GameWaitRoom_gameEndPtr;

class Callback_MapInterface_getId_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapInterface_getId_Base> Callback_MapInterface_getIdPtr;

class Callback_MapInterface_getWidth_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapInterface_getWidth_Base> Callback_MapInterface_getWidthPtr;

class Callback_MapInterface_getHeight_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapInterface_getHeight_Base> Callback_MapInterface_getHeightPtr;

class Callback_MapInterface_move_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapInterface_move_Base> Callback_MapInterface_movePtr;

class Callback_MapInterface_kickBomb_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapInterface_kickBomb_Base> Callback_MapInterface_kickBombPtr;

class Callback_MapInterface_dropBomb_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapInterface_dropBomb_Base> Callback_MapInterface_dropBombPtr;

class Callback_MapObserver_refreshMapItems_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapObserver_refreshMapItems_Base> Callback_MapObserver_refreshMapItemsPtr;

class Callback_MapObserver_refreshPlayers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapObserver_refreshPlayers_Base> Callback_MapObserver_refreshPlayersPtr;

class Callback_MapObserver_bombHasBeenPlanted_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapObserver_bombHasBeenPlanted_Base> Callback_MapObserver_bombHasBeenPlantedPtr;

class Callback_MapObserver_bombExploded_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapObserver_bombExploded_Base> Callback_MapObserver_bombExplodedPtr;

class Callback_MapObserver_bonusesDropped_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MapObserver_bonusesDropped_Base> Callback_MapObserver_bonusesDroppedPtr;

class Callback_ServerInterface_connect_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerInterface_connect_Base> Callback_ServerInterface_connectPtr;

class Callback_ServerInterface_createUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerInterface_createUser_Base> Callback_ServerInterface_createUserPtr;

class Callback_ServerInterface_deleteUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerInterface_deleteUser_Base> Callback_ServerInterface_deleteUserPtr;

class Callback_ServerInterface_addGame_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerInterface_addGame_Base> Callback_ServerInterface_addGamePtr;

class Callback_ServerInterface_joinGame_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerInterface_joinGame_Base> Callback_ServerInterface_joinGamePtr;

class Callback_ServerInterface_getGameList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerInterface_getGameList_Base> Callback_ServerInterface_getGameListPtr;

class Callback_ServerInterface_getUserList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerInterface_getUserList_Base> Callback_ServerInterface_getUserListPtr;

}

namespace IceProxy
{

namespace Bomberloutre
{

class GameInterface : virtual public ::IceProxy::Ice::Object
{
public:

    ::std::string getName()
    {
        return getName(0);
    }
    ::std::string getName(const ::Ice::Context& __ctx)
    {
        return getName(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getName()
    {
        return begin_getName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx)
    {
        return begin_getName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Bomberloutre::Callback_GameInterface_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getState()
    {
        return getState(0);
    }
    ::Ice::Int getState(const ::Ice::Context& __ctx)
    {
        return getState(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getState()
    {
        return begin_getState(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getState(const ::Ice::Context& __ctx)
    {
        return begin_getState(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getState(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getState(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getState(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getState(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getState(const ::Bomberloutre::Callback_GameInterface_getStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getState(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getState(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_getStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getState(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getState(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getState(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getState(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getRoundCount()
    {
        return getRoundCount(0);
    }
    ::Ice::Int getRoundCount(const ::Ice::Context& __ctx)
    {
        return getRoundCount(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getRoundCount()
    {
        return begin_getRoundCount(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRoundCount(const ::Ice::Context& __ctx)
    {
        return begin_getRoundCount(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRoundCount(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoundCount(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoundCount(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoundCount(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoundCount(const ::Bomberloutre::Callback_GameInterface_getRoundCountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoundCount(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRoundCount(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_getRoundCountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRoundCount(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getRoundCount(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getRoundCount(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRoundCount(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setName(const ::std::string& newname)
    {
        setName(newname, 0);
    }
    void setName(const ::std::string& newname, const ::Ice::Context& __ctx)
    {
        setName(newname, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& newname)
    {
        return begin_setName(newname, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& newname, const ::Ice::Context& __ctx)
    {
        return begin_setName(newname, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& newname, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(newname, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& newname, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(newname, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& newname, const ::Bomberloutre::Callback_GameInterface_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(newname, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& newname, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(newname, &__ctx, __del, __cookie);
    }

    void end_setName(const ::Ice::AsyncResultPtr&);
    
private:

    void setName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setState(::Ice::Int newstate)
    {
        setState(newstate, 0);
    }
    void setState(::Ice::Int newstate, const ::Ice::Context& __ctx)
    {
        setState(newstate, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setState(::Ice::Int newstate)
    {
        return begin_setState(newstate, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setState(::Ice::Int newstate, const ::Ice::Context& __ctx)
    {
        return begin_setState(newstate, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setState(::Ice::Int newstate, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setState(newstate, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setState(::Ice::Int newstate, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setState(newstate, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setState(::Ice::Int newstate, const ::Bomberloutre::Callback_GameInterface_setStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setState(newstate, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setState(::Ice::Int newstate, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_setStatePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setState(newstate, &__ctx, __del, __cookie);
    }

    void end_setState(const ::Ice::AsyncResultPtr&);
    
private:

    void setState(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setState(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setRoundCount(::Ice::Int newcount)
    {
        setRoundCount(newcount, 0);
    }
    void setRoundCount(::Ice::Int newcount, const ::Ice::Context& __ctx)
    {
        setRoundCount(newcount, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setRoundCount(::Ice::Int newcount)
    {
        return begin_setRoundCount(newcount, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRoundCount(::Ice::Int newcount, const ::Ice::Context& __ctx)
    {
        return begin_setRoundCount(newcount, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setRoundCount(::Ice::Int newcount, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRoundCount(newcount, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRoundCount(::Ice::Int newcount, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRoundCount(newcount, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRoundCount(::Ice::Int newcount, const ::Bomberloutre::Callback_GameInterface_setRoundCountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRoundCount(newcount, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setRoundCount(::Ice::Int newcount, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_setRoundCountPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setRoundCount(newcount, &__ctx, __del, __cookie);
    }

    void end_setRoundCount(const ::Ice::AsyncResultPtr&);
    
private:

    void setRoundCount(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setRoundCount(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void kickPlayer(const ::std::string& username)
    {
        kickPlayer(username, 0);
    }
    void kickPlayer(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        kickPlayer(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username)
    {
        return begin_kickPlayer(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_kickPlayer(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickPlayer(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickPlayer(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Bomberloutre::Callback_GameInterface_kickPlayerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickPlayer(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_kickPlayerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickPlayer(username, &__ctx, __del, __cookie);
    }

    void end_kickPlayer(const ::Ice::AsyncResultPtr&);
    
private:

    void kickPlayer(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_kickPlayer(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void invitePlayer(const ::std::string& username)
    {
        invitePlayer(username, 0);
    }
    void invitePlayer(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        invitePlayer(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username)
    {
        return begin_invitePlayer(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_invitePlayer(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitePlayer(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitePlayer(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Bomberloutre::Callback_GameInterface_invitePlayerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitePlayer(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_invitePlayerPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_invitePlayer(username, &__ctx, __del, __cookie);
    }

    void end_invitePlayer(const ::Ice::AsyncResultPtr&);
    
private:

    void invitePlayer(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_invitePlayer(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void addBot()
    {
        addBot(0);
    }
    void addBot(const ::Ice::Context& __ctx)
    {
        addBot(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_addBot()
    {
        return begin_addBot(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::Context& __ctx)
    {
        return begin_addBot(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addBot(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addBot(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Bomberloutre::Callback_GameInterface_addBotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addBot(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_addBotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addBot(&__ctx, __del, __cookie);
    }

    void end_addBot(const ::Ice::AsyncResultPtr&);
    
private:

    void addBot(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addBot(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void removeBot()
    {
        removeBot(0);
    }
    void removeBot(const ::Ice::Context& __ctx)
    {
        removeBot(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeBot()
    {
        return begin_removeBot(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::Context& __ctx)
    {
        return begin_removeBot(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeBot(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeBot(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Bomberloutre::Callback_GameInterface_removeBotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeBot(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_removeBotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeBot(&__ctx, __del, __cookie);
    }

    void end_removeBot(const ::Ice::AsyncResultPtr&);
    
private:

    void removeBot(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeBot(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool createMap(const ::std::string& mode, const ::std::string& mapSkin)
    {
        return createMap(mode, mapSkin, 0);
    }
    bool createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context& __ctx)
    {
        return createMap(mode, mapSkin, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin)
    {
        return begin_createMap(mode, mapSkin, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context& __ctx)
    {
        return begin_createMap(mode, mapSkin, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createMap(mode, mapSkin, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createMap(mode, mapSkin, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Bomberloutre::Callback_GameInterface_createMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createMap(mode, mapSkin, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_createMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createMap(mode, mapSkin, &__ctx, __del, __cookie);
    }

    bool end_createMap(const ::Ice::AsyncResultPtr&);
    
private:

    bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void startMap()
    {
        startMap(0);
    }
    void startMap(const ::Ice::Context& __ctx)
    {
        startMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_startMap()
    {
        return begin_startMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::Context& __ctx)
    {
        return begin_startMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Bomberloutre::Callback_GameInterface_startMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_startMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startMap(&__ctx, __del, __cookie);
    }

    void end_startMap(const ::Ice::AsyncResultPtr&);
    
private:

    void startMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_startMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void endMap()
    {
        endMap(0);
    }
    void endMap(const ::Ice::Context& __ctx)
    {
        endMap(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_endMap()
    {
        return begin_endMap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::Context& __ctx)
    {
        return begin_endMap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_endMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_endMap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Bomberloutre::Callback_GameInterface_endMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_endMap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_endMapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_endMap(&__ctx, __del, __cookie);
    }

    void end_endMap(const ::Ice::AsyncResultPtr&);
    
private:

    void endMap(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_endMap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool removeGame()
    {
        return removeGame(0);
    }
    bool removeGame(const ::Ice::Context& __ctx)
    {
        return removeGame(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_removeGame()
    {
        return begin_removeGame(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::Ice::Context& __ctx)
    {
        return begin_removeGame(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGame(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGame(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::Bomberloutre::Callback_GameInterface_removeGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGame(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_removeGame(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameInterface_removeGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_removeGame(&__ctx, __del, __cookie);
    }

    bool end_removeGame(const ::Ice::AsyncResultPtr&);
    
private:

    bool removeGame(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_removeGame(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<GameInterface> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameInterface> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameInterface*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<GameInterface*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class GameWaitRoom : virtual public ::IceProxy::Ice::Object
{
public:

    void newUserInRoom(const ::std::string& username)
    {
        newUserInRoom(username, 0);
    }
    void newUserInRoom(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        newUserInRoom(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username)
    {
        return begin_newUserInRoom(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_newUserInRoom(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newUserInRoom(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newUserInRoom(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Bomberloutre::Callback_GameWaitRoom_newUserInRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newUserInRoom(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_newUserInRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newUserInRoom(username, &__ctx, __del, __cookie);
    }

    void end_newUserInRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void newUserInRoom(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_newUserInRoom(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void userLeftRoom(const ::std::string& username)
    {
        userLeftRoom(username, 0);
    }
    void userLeftRoom(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        userLeftRoom(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username)
    {
        return begin_userLeftRoom(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_userLeftRoom(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userLeftRoom(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userLeftRoom(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Bomberloutre::Callback_GameWaitRoom_userLeftRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userLeftRoom(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_userLeftRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userLeftRoom(username, &__ctx, __del, __cookie);
    }

    void end_userLeftRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void userLeftRoom(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_userLeftRoom(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void allUsersReady()
    {
        allUsersReady(0);
    }
    void allUsersReady(const ::Ice::Context& __ctx)
    {
        allUsersReady(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady()
    {
        return begin_allUsersReady(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::Context& __ctx)
    {
        return begin_allUsersReady(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allUsersReady(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allUsersReady(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Bomberloutre::Callback_GameWaitRoom_allUsersReadyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allUsersReady(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_allUsersReadyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_allUsersReady(&__ctx, __del, __cookie);
    }

    void end_allUsersReady(const ::Ice::AsyncResultPtr&);
    
private:

    void allUsersReady(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_allUsersReady(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void userReady(const ::std::string& username)
    {
        userReady(username, 0);
    }
    void userReady(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        userReady(username, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username)
    {
        return begin_userReady(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_userReady(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userReady(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userReady(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Bomberloutre::Callback_GameWaitRoom_userReadyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userReady(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_userReady(const ::std::string& username, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_userReadyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_userReady(username, &__ctx, __del, __cookie);
    }

    void end_userReady(const ::Ice::AsyncResultPtr&);
    
private:

    void userReady(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_userReady(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void gameStart()
    {
        gameStart(0);
    }
    void gameStart(const ::Ice::Context& __ctx)
    {
        gameStart(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_gameStart()
    {
        return begin_gameStart(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_gameStart(const ::Ice::Context& __ctx)
    {
        return begin_gameStart(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_gameStart(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_gameStart(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_gameStart(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_gameStart(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_gameStart(const ::Bomberloutre::Callback_GameWaitRoom_gameStartPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_gameStart(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_gameStart(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_gameStartPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_gameStart(&__ctx, __del, __cookie);
    }

    void end_gameStart(const ::Ice::AsyncResultPtr&);
    
private:

    void gameStart(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_gameStart(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void gameEnd()
    {
        gameEnd(0);
    }
    void gameEnd(const ::Ice::Context& __ctx)
    {
        gameEnd(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_gameEnd()
    {
        return begin_gameEnd(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_gameEnd(const ::Ice::Context& __ctx)
    {
        return begin_gameEnd(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_gameEnd(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_gameEnd(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_gameEnd(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_gameEnd(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_gameEnd(const ::Bomberloutre::Callback_GameWaitRoom_gameEndPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_gameEnd(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_gameEnd(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_GameWaitRoom_gameEndPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_gameEnd(&__ctx, __del, __cookie);
    }

    void end_gameEnd(const ::Ice::AsyncResultPtr&);
    
private:

    void gameEnd(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_gameEnd(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<GameWaitRoom> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<GameWaitRoom*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<GameWaitRoom*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MapInterface : virtual public ::IceProxy::Ice::Object
{
public:

    ::std::string getId()
    {
        return getId(0);
    }
    ::std::string getId(const ::Ice::Context& __ctx)
    {
        return getId(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getId()
    {
        return begin_getId(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Ice::Context& __ctx)
    {
        return begin_getId(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getId(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getId(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Bomberloutre::Callback_MapInterface_getIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getId(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapInterface_getIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getId(&__ctx, __del, __cookie);
    }

    ::std::string end_getId(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getId(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getId(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getWidth()
    {
        return getWidth(0);
    }
    ::Ice::Int getWidth(const ::Ice::Context& __ctx)
    {
        return getWidth(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getWidth()
    {
        return begin_getWidth(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getWidth(const ::Ice::Context& __ctx)
    {
        return begin_getWidth(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getWidth(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getWidth(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getWidth(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getWidth(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getWidth(const ::Bomberloutre::Callback_MapInterface_getWidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getWidth(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getWidth(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapInterface_getWidthPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getWidth(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getWidth(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getWidth(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getWidth(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getHeight()
    {
        return getHeight(0);
    }
    ::Ice::Int getHeight(const ::Ice::Context& __ctx)
    {
        return getHeight(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getHeight()
    {
        return begin_getHeight(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHeight(const ::Ice::Context& __ctx)
    {
        return begin_getHeight(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHeight(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHeight(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHeight(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHeight(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHeight(const ::Bomberloutre::Callback_MapInterface_getHeightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHeight(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHeight(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapInterface_getHeightPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHeight(&__ctx, __del, __cookie);
    }

    ::Ice::Int end_getHeight(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getHeight(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getHeight(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt)
    {
        return move(p, pt, 0);
    }
    bool move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Context& __ctx)
    {
        return move(p, pt, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt)
    {
        return begin_move(p, pt, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Context& __ctx)
    {
        return begin_move(p, pt, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_move(p, pt, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_move(p, pt, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Bomberloutre::Callback_MapInterface_movePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_move(p, pt, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapInterface_movePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_move(p, pt, &__ctx, __del, __cookie);
    }

    bool end_move(const ::Ice::AsyncResultPtr&);
    
private:

    bool move(const ::Bomberloutre::Player&, const ::Bomberloutre::Point&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_move(const ::Bomberloutre::Player&, const ::Bomberloutre::Point&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void kickBomb(const ::Bomberloutre::Player& p)
    {
        kickBomb(p, 0);
    }
    void kickBomb(const ::Bomberloutre::Player& p, const ::Ice::Context& __ctx)
    {
        kickBomb(p, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_kickBomb(const ::Bomberloutre::Player& p)
    {
        return begin_kickBomb(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kickBomb(const ::Bomberloutre::Player& p, const ::Ice::Context& __ctx)
    {
        return begin_kickBomb(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kickBomb(const ::Bomberloutre::Player& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickBomb(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickBomb(const ::Bomberloutre::Player& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickBomb(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::Callback_MapInterface_kickBombPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickBomb(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kickBomb(const ::Bomberloutre::Player& p, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapInterface_kickBombPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kickBomb(p, &__ctx, __del, __cookie);
    }

    void end_kickBomb(const ::Ice::AsyncResultPtr&);
    
private:

    void kickBomb(const ::Bomberloutre::Player&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_kickBomb(const ::Bomberloutre::Player&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b)
    {
        dropBomb(p, b, 0);
    }
    void dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx)
    {
        dropBomb(p, b, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b)
    {
        return begin_dropBomb(p, b, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx)
    {
        return begin_dropBomb(p, b, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dropBomb(p, b, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dropBomb(p, b, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Bomberloutre::Callback_MapInterface_dropBombPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dropBomb(p, b, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapInterface_dropBombPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dropBomb(p, b, &__ctx, __del, __cookie);
    }

    void end_dropBomb(const ::Ice::AsyncResultPtr&);
    
private:

    void dropBomb(const ::Bomberloutre::Player&, const ::Bomberloutre::BombPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_dropBomb(const ::Bomberloutre::Player&, const ::Bomberloutre::BombPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MapInterface> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapInterface> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapInterface*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<MapInterface*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MapObserver : virtual public ::IceProxy::Ice::Object
{
public:

    void refreshMapItems(const ::Bomberloutre::MapItems& mi)
    {
        refreshMapItems(mi, 0);
    }
    void refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::Context& __ctx)
    {
        refreshMapItems(mi, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_refreshMapItems(const ::Bomberloutre::MapItems& mi)
    {
        return begin_refreshMapItems(mi, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::Context& __ctx)
    {
        return begin_refreshMapItems(mi, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshMapItems(mi, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshMapItems(mi, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Bomberloutre::Callback_MapObserver_refreshMapItemsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshMapItems(mi, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapObserver_refreshMapItemsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshMapItems(mi, &__ctx, __del, __cookie);
    }

    void end_refreshMapItems(const ::Ice::AsyncResultPtr&);
    
private:

    void refreshMapItems(const ::Bomberloutre::MapItems&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_refreshMapItems(const ::Bomberloutre::MapItems&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void refreshPlayers(const ::Bomberloutre::PlayerList& p)
    {
        refreshPlayers(p, 0);
    }
    void refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::Context& __ctx)
    {
        refreshPlayers(p, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_refreshPlayers(const ::Bomberloutre::PlayerList& p)
    {
        return begin_refreshPlayers(p, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::Context& __ctx)
    {
        return begin_refreshPlayers(p, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshPlayers(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshPlayers(p, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Bomberloutre::Callback_MapObserver_refreshPlayersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshPlayers(p, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapObserver_refreshPlayersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshPlayers(p, &__ctx, __del, __cookie);
    }

    void end_refreshPlayers(const ::Ice::AsyncResultPtr&);
    
private:

    void refreshPlayers(const ::Bomberloutre::PlayerList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_refreshPlayers(const ::Bomberloutre::PlayerList&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b)
    {
        bombHasBeenPlanted(b, 0);
    }
    void bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx)
    {
        bombHasBeenPlanted(b, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b)
    {
        return begin_bombHasBeenPlanted(b, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx)
    {
        return begin_bombHasBeenPlanted(b, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bombHasBeenPlanted(b, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bombHasBeenPlanted(b, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Bomberloutre::Callback_MapObserver_bombHasBeenPlantedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bombHasBeenPlanted(b, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapObserver_bombHasBeenPlantedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bombHasBeenPlanted(b, &__ctx, __del, __cookie);
    }

    void end_bombHasBeenPlanted(const ::Ice::AsyncResultPtr&);
    
private:

    void bombHasBeenPlanted(const ::Bomberloutre::BombPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_bombHasBeenPlanted(const ::Bomberloutre::BombPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void bombExploded(const ::Bomberloutre::BombPtr& b)
    {
        bombExploded(b, 0);
    }
    void bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx)
    {
        bombExploded(b, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_bombExploded(const ::Bomberloutre::BombPtr& b)
    {
        return begin_bombExploded(b, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx)
    {
        return begin_bombExploded(b, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bombExploded(b, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bombExploded(b, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bombExploded(const ::Bomberloutre::BombPtr& b, const ::Bomberloutre::Callback_MapObserver_bombExplodedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bombExploded(b, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapObserver_bombExplodedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bombExploded(b, &__ctx, __del, __cookie);
    }

    void end_bombExploded(const ::Ice::AsyncResultPtr&);
    
private:

    void bombExploded(const ::Bomberloutre::BombPtr&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_bombExploded(const ::Bomberloutre::BombPtr&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void bonusesDropped(const ::Bomberloutre::Bonuses& b)
    {
        bonusesDropped(b, 0);
    }
    void bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::Context& __ctx)
    {
        bonusesDropped(b, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_bonusesDropped(const ::Bomberloutre::Bonuses& b)
    {
        return begin_bonusesDropped(b, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::Context& __ctx)
    {
        return begin_bonusesDropped(b, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bonusesDropped(b, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bonusesDropped(b, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Bomberloutre::Callback_MapObserver_bonusesDroppedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bonusesDropped(b, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_MapObserver_bonusesDroppedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_bonusesDropped(b, &__ctx, __del, __cookie);
    }

    void end_bonusesDropped(const ::Ice::AsyncResultPtr&);
    
private:

    void bonusesDropped(const ::Bomberloutre::Bonuses&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_bonusesDropped(const ::Bomberloutre::Bonuses&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MapObserver> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<MapObserver> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<MapObserver*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<MapObserver*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ServerInterface : virtual public ::IceProxy::Ice::Object
{
public:

    ::Bomberloutre::UserData connect(const ::std::string& login, const ::std::string& password)
    {
        return connect(login, password, 0);
    }
    ::Bomberloutre::UserData connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context& __ctx)
    {
        return connect(login, password, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_connect(const ::std::string& login, const ::std::string& password)
    {
        return begin_connect(login, password, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context& __ctx)
    {
        return begin_connect(login, password, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_connect(const ::std::string& login, const ::std::string& password, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_connect(login, password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_connect(login, password, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_connect(const ::std::string& login, const ::std::string& password, const ::Bomberloutre::Callback_ServerInterface_connectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_connect(login, password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_ServerInterface_connectPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_connect(login, password, &__ctx, __del, __cookie);
    }

    ::Bomberloutre::UserData end_connect(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::UserData connect(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_connect(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Bomberloutre::UserData createUser(const ::std::string& login, const ::std::string& password)
    {
        return createUser(login, password, 0);
    }
    ::Bomberloutre::UserData createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context& __ctx)
    {
        return createUser(login, password, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_createUser(const ::std::string& login, const ::std::string& password)
    {
        return begin_createUser(login, password, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context& __ctx)
    {
        return begin_createUser(login, password, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_createUser(const ::std::string& login, const ::std::string& password, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createUser(login, password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createUser(login, password, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createUser(const ::std::string& login, const ::std::string& password, const ::Bomberloutre::Callback_ServerInterface_createUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createUser(login, password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_ServerInterface_createUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_createUser(login, password, &__ctx, __del, __cookie);
    }

    ::Bomberloutre::UserData end_createUser(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::UserData createUser(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_createUser(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool deleteUser(const ::std::string& login)
    {
        return deleteUser(login, 0);
    }
    bool deleteUser(const ::std::string& login, const ::Ice::Context& __ctx)
    {
        return deleteUser(login, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::std::string& login)
    {
        return begin_deleteUser(login, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::std::string& login, const ::Ice::Context& __ctx)
    {
        return begin_deleteUser(login, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::std::string& login, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteUser(login, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::std::string& login, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteUser(login, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::std::string& login, const ::Bomberloutre::Callback_ServerInterface_deleteUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteUser(login, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteUser(const ::std::string& login, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_ServerInterface_deleteUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_deleteUser(login, &__ctx, __del, __cookie);
    }

    bool end_deleteUser(const ::Ice::AsyncResultPtr&);
    
private:

    bool deleteUser(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_deleteUser(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Bomberloutre::GameInterfacePrx addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo)
    {
        return addGame(name, room, mo, 0);
    }
    ::Bomberloutre::GameInterfacePrx addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx)
    {
        return addGame(name, room, mo, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo)
    {
        return begin_addGame(name, room, mo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx)
    {
        return begin_addGame(name, room, mo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGame(name, room, mo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGame(name, room, mo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Bomberloutre::Callback_ServerInterface_addGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGame(name, room, mo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_ServerInterface_addGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_addGame(name, room, mo, &__ctx, __del, __cookie);
    }

    ::Bomberloutre::GameInterfacePrx end_addGame(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::GameInterfacePrx addGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_addGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Bomberloutre::Map joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo)
    {
        return joinGame(name, room, mo, 0);
    }
    ::Bomberloutre::Map joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx)
    {
        return joinGame(name, room, mo, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo)
    {
        return begin_joinGame(name, room, mo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx)
    {
        return begin_joinGame(name, room, mo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinGame(name, room, mo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinGame(name, room, mo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Bomberloutre::Callback_ServerInterface_joinGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinGame(name, room, mo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_ServerInterface_joinGamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinGame(name, room, mo, &__ctx, __del, __cookie);
    }

    ::Bomberloutre::Map end_joinGame(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::Map joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Bomberloutre::GameDataList getGameList()
    {
        return getGameList(0);
    }
    ::Bomberloutre::GameDataList getGameList(const ::Ice::Context& __ctx)
    {
        return getGameList(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getGameList()
    {
        return begin_getGameList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::Context& __ctx)
    {
        return begin_getGameList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGameList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGameList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Bomberloutre::Callback_ServerInterface_getGameListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGameList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_ServerInterface_getGameListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGameList(&__ctx, __del, __cookie);
    }

    ::Bomberloutre::GameDataList end_getGameList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::GameDataList getGameList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getGameList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Bomberloutre::UserDataList getUserList()
    {
        return getUserList(0);
    }
    ::Bomberloutre::UserDataList getUserList(const ::Ice::Context& __ctx)
    {
        return getUserList(&__ctx);
    }

    ::Ice::AsyncResultPtr begin_getUserList()
    {
        return begin_getUserList(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::Context& __ctx)
    {
        return begin_getUserList(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserList(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Bomberloutre::Callback_ServerInterface_getUserListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserList(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::Context& __ctx, const ::Bomberloutre::Callback_ServerInterface_getUserListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUserList(&__ctx, __del, __cookie);
    }

    ::Bomberloutre::UserDataList end_getUserList(const ::Ice::AsyncResultPtr&);
    
private:

    ::Bomberloutre::UserDataList getUserList(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUserList(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<ServerInterface> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<ServerInterface*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<ServerInterface*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Bomberloutre
{

class GameInterface : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::std::string getName(const ::Ice::Context*) = 0;

    virtual ::Ice::Int getState(const ::Ice::Context*) = 0;

    virtual ::Ice::Int getRoundCount(const ::Ice::Context*) = 0;

    virtual void setName(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void setState(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void setRoundCount(::Ice::Int, const ::Ice::Context*) = 0;

    virtual void kickPlayer(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void invitePlayer(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void addBot(const ::Ice::Context*) = 0;

    virtual void removeBot(const ::Ice::Context*) = 0;

    virtual bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual void startMap(const ::Ice::Context*) = 0;

    virtual void endMap(const ::Ice::Context*) = 0;

    virtual bool removeGame(const ::Ice::Context*) = 0;
};

class GameWaitRoom : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void newUserInRoom(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void userLeftRoom(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void allUsersReady(const ::Ice::Context*) = 0;

    virtual void userReady(const ::std::string&, const ::Ice::Context*) = 0;

    virtual void gameStart(const ::Ice::Context*) = 0;

    virtual void gameEnd(const ::Ice::Context*) = 0;
};

class MapInterface : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::std::string getId(const ::Ice::Context*) = 0;

    virtual ::Ice::Int getWidth(const ::Ice::Context*) = 0;

    virtual ::Ice::Int getHeight(const ::Ice::Context*) = 0;

    virtual bool move(const ::Bomberloutre::Player&, const ::Bomberloutre::Point&, const ::Ice::Context*) = 0;

    virtual void kickBomb(const ::Bomberloutre::Player&, const ::Ice::Context*) = 0;

    virtual void dropBomb(const ::Bomberloutre::Player&, const ::Bomberloutre::BombPtr&, const ::Ice::Context*) = 0;
};

class MapObserver : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void refreshMapItems(const ::Bomberloutre::MapItems&, const ::Ice::Context*) = 0;

    virtual void refreshPlayers(const ::Bomberloutre::PlayerList&, const ::Ice::Context*) = 0;

    virtual void bombHasBeenPlanted(const ::Bomberloutre::BombPtr&, const ::Ice::Context*) = 0;

    virtual void bombExploded(const ::Bomberloutre::BombPtr&, const ::Ice::Context*) = 0;

    virtual void bonusesDropped(const ::Bomberloutre::Bonuses&, const ::Ice::Context*) = 0;
};

class ServerInterface : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Bomberloutre::UserData connect(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Bomberloutre::UserData createUser(const ::std::string&, const ::std::string&, const ::Ice::Context*) = 0;

    virtual bool deleteUser(const ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Bomberloutre::GameInterfacePrx addGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*) = 0;

    virtual ::Bomberloutre::Map joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*) = 0;

    virtual ::Bomberloutre::GameDataList getGameList(const ::Ice::Context*) = 0;

    virtual ::Bomberloutre::UserDataList getUserList(const ::Ice::Context*) = 0;
};

}

}

namespace IceDelegateM
{

namespace Bomberloutre
{

class GameInterface : virtual public ::IceDelegate::Bomberloutre::GameInterface,
                      virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::std::string getName(const ::Ice::Context*);

    virtual ::Ice::Int getState(const ::Ice::Context*);

    virtual ::Ice::Int getRoundCount(const ::Ice::Context*);

    virtual void setName(const ::std::string&, const ::Ice::Context*);

    virtual void setState(::Ice::Int, const ::Ice::Context*);

    virtual void setRoundCount(::Ice::Int, const ::Ice::Context*);

    virtual void kickPlayer(const ::std::string&, const ::Ice::Context*);

    virtual void invitePlayer(const ::std::string&, const ::Ice::Context*);

    virtual void addBot(const ::Ice::Context*);

    virtual void removeBot(const ::Ice::Context*);

    virtual bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void startMap(const ::Ice::Context*);

    virtual void endMap(const ::Ice::Context*);

    virtual bool removeGame(const ::Ice::Context*);
};

class GameWaitRoom : virtual public ::IceDelegate::Bomberloutre::GameWaitRoom,
                     virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void newUserInRoom(const ::std::string&, const ::Ice::Context*);

    virtual void userLeftRoom(const ::std::string&, const ::Ice::Context*);

    virtual void allUsersReady(const ::Ice::Context*);

    virtual void userReady(const ::std::string&, const ::Ice::Context*);

    virtual void gameStart(const ::Ice::Context*);

    virtual void gameEnd(const ::Ice::Context*);
};

class MapInterface : virtual public ::IceDelegate::Bomberloutre::MapInterface,
                     virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::std::string getId(const ::Ice::Context*);

    virtual ::Ice::Int getWidth(const ::Ice::Context*);

    virtual ::Ice::Int getHeight(const ::Ice::Context*);

    virtual bool move(const ::Bomberloutre::Player&, const ::Bomberloutre::Point&, const ::Ice::Context*);

    virtual void kickBomb(const ::Bomberloutre::Player&, const ::Ice::Context*);

    virtual void dropBomb(const ::Bomberloutre::Player&, const ::Bomberloutre::BombPtr&, const ::Ice::Context*);
};

class MapObserver : virtual public ::IceDelegate::Bomberloutre::MapObserver,
                    virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void refreshMapItems(const ::Bomberloutre::MapItems&, const ::Ice::Context*);

    virtual void refreshPlayers(const ::Bomberloutre::PlayerList&, const ::Ice::Context*);

    virtual void bombHasBeenPlanted(const ::Bomberloutre::BombPtr&, const ::Ice::Context*);

    virtual void bombExploded(const ::Bomberloutre::BombPtr&, const ::Ice::Context*);

    virtual void bonusesDropped(const ::Bomberloutre::Bonuses&, const ::Ice::Context*);
};

class ServerInterface : virtual public ::IceDelegate::Bomberloutre::ServerInterface,
                        virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Bomberloutre::UserData connect(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual ::Bomberloutre::UserData createUser(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual bool deleteUser(const ::std::string&, const ::Ice::Context*);

    virtual ::Bomberloutre::GameInterfacePrx addGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);

    virtual ::Bomberloutre::Map joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);

    virtual ::Bomberloutre::GameDataList getGameList(const ::Ice::Context*);

    virtual ::Bomberloutre::UserDataList getUserList(const ::Ice::Context*);
};

}

}

namespace IceDelegateD
{

namespace Bomberloutre
{

class GameInterface : virtual public ::IceDelegate::Bomberloutre::GameInterface,
                      virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::std::string getName(const ::Ice::Context*);

    virtual ::Ice::Int getState(const ::Ice::Context*);

    virtual ::Ice::Int getRoundCount(const ::Ice::Context*);

    virtual void setName(const ::std::string&, const ::Ice::Context*);

    virtual void setState(::Ice::Int, const ::Ice::Context*);

    virtual void setRoundCount(::Ice::Int, const ::Ice::Context*);

    virtual void kickPlayer(const ::std::string&, const ::Ice::Context*);

    virtual void invitePlayer(const ::std::string&, const ::Ice::Context*);

    virtual void addBot(const ::Ice::Context*);

    virtual void removeBot(const ::Ice::Context*);

    virtual bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual void startMap(const ::Ice::Context*);

    virtual void endMap(const ::Ice::Context*);

    virtual bool removeGame(const ::Ice::Context*);
};

class GameWaitRoom : virtual public ::IceDelegate::Bomberloutre::GameWaitRoom,
                     virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void newUserInRoom(const ::std::string&, const ::Ice::Context*);

    virtual void userLeftRoom(const ::std::string&, const ::Ice::Context*);

    virtual void allUsersReady(const ::Ice::Context*);

    virtual void userReady(const ::std::string&, const ::Ice::Context*);

    virtual void gameStart(const ::Ice::Context*);

    virtual void gameEnd(const ::Ice::Context*);
};

class MapInterface : virtual public ::IceDelegate::Bomberloutre::MapInterface,
                     virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::std::string getId(const ::Ice::Context*);

    virtual ::Ice::Int getWidth(const ::Ice::Context*);

    virtual ::Ice::Int getHeight(const ::Ice::Context*);

    virtual bool move(const ::Bomberloutre::Player&, const ::Bomberloutre::Point&, const ::Ice::Context*);

    virtual void kickBomb(const ::Bomberloutre::Player&, const ::Ice::Context*);

    virtual void dropBomb(const ::Bomberloutre::Player&, const ::Bomberloutre::BombPtr&, const ::Ice::Context*);
};

class MapObserver : virtual public ::IceDelegate::Bomberloutre::MapObserver,
                    virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void refreshMapItems(const ::Bomberloutre::MapItems&, const ::Ice::Context*);

    virtual void refreshPlayers(const ::Bomberloutre::PlayerList&, const ::Ice::Context*);

    virtual void bombHasBeenPlanted(const ::Bomberloutre::BombPtr&, const ::Ice::Context*);

    virtual void bombExploded(const ::Bomberloutre::BombPtr&, const ::Ice::Context*);

    virtual void bonusesDropped(const ::Bomberloutre::Bonuses&, const ::Ice::Context*);
};

class ServerInterface : virtual public ::IceDelegate::Bomberloutre::ServerInterface,
                        virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Bomberloutre::UserData connect(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual ::Bomberloutre::UserData createUser(const ::std::string&, const ::std::string&, const ::Ice::Context*);

    virtual bool deleteUser(const ::std::string&, const ::Ice::Context*);

    virtual ::Bomberloutre::GameInterfacePrx addGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);

    virtual ::Bomberloutre::Map joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Context*);

    virtual ::Bomberloutre::GameDataList getGameList(const ::Ice::Context*);

    virtual ::Bomberloutre::UserDataList getUserList(const ::Ice::Context*);
};

}

}

namespace Bomberloutre
{

class GameInterface : virtual public ::Ice::Object
{
public:

    typedef GameInterfacePrx ProxyType;
    typedef GameInterfacePtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::std::string getName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getState(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getState(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getRoundCount(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRoundCount(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setState(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setState(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setRoundCount(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setRoundCount(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void kickPlayer(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___kickPlayer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void invitePlayer(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___invitePlayer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void addBot(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addBot(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void removeBot(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeBot(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool createMap(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void startMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___startMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void endMap(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___endMap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool removeGame(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___removeGame(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const GameInterface& l, const GameInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const GameInterface& l, const GameInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class GameWaitRoom : virtual public ::Ice::Object
{
public:

    typedef GameWaitRoomPrx ProxyType;
    typedef GameWaitRoomPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void newUserInRoom(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___newUserInRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void userLeftRoom(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___userLeftRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void allUsersReady(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___allUsersReady(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void userReady(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___userReady(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void gameStart(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___gameStart(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void gameEnd(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___gameEnd(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const GameWaitRoom& l, const GameWaitRoom& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const GameWaitRoom& l, const GameWaitRoom& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MapInterface : virtual public ::Ice::Object
{
public:

    typedef MapInterfacePrx ProxyType;
    typedef MapInterfacePtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::std::string getId(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getId(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getWidth(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getWidth(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getHeight(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getHeight(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool move(const ::Bomberloutre::Player&, const ::Bomberloutre::Point&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___move(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void kickBomb(const ::Bomberloutre::Player&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___kickBomb(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void dropBomb(const ::Bomberloutre::Player&, const ::Bomberloutre::BombPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___dropBomb(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const MapInterface& l, const MapInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MapInterface& l, const MapInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MapObserver : virtual public ::Ice::Object
{
public:

    typedef MapObserverPrx ProxyType;
    typedef MapObserverPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void refreshMapItems(const ::Bomberloutre::MapItems&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___refreshMapItems(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void refreshPlayers(const ::Bomberloutre::PlayerList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___refreshPlayers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void bombHasBeenPlanted(const ::Bomberloutre::BombPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___bombHasBeenPlanted(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void bombExploded(const ::Bomberloutre::BombPtr&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___bombExploded(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void bonusesDropped(const ::Bomberloutre::Bonuses&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___bonusesDropped(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const MapObserver& l, const MapObserver& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MapObserver& l, const MapObserver& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ServerInterface : virtual public ::Ice::Object
{
public:

    typedef ServerInterfacePrx ProxyType;
    typedef ServerInterfacePtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Bomberloutre::UserData connect(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___connect(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Bomberloutre::UserData createUser(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___createUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool deleteUser(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___deleteUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Bomberloutre::GameInterfacePrx addGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___addGame(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Bomberloutre::Map joinGame(const ::std::string&, const ::Bomberloutre::GameWaitRoomPrx&, const ::Bomberloutre::MapObserverPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___joinGame(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Bomberloutre::GameDataList getGameList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getGameList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Bomberloutre::UserDataList getUserList(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUserList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const ServerInterface& l, const ServerInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ServerInterface& l, const ServerInterface& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Bomberloutre
{

template<class T>
class CallbackNC_GameInterface_getName : public Callback_GameInterface_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_GameInterface_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GameInterface_getNamePtr
newCallback_GameInterface_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_getName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_getNamePtr
newCallback_GameInterface_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_getName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_getName : public Callback_GameInterface_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_GameInterface_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GameInterface_getNamePtr
newCallback_GameInterface_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_getNamePtr
newCallback_GameInterface_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_getState : public Callback_GameInterface_getState_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_GameInterface_getState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GameInterface_getStatePtr
newCallback_GameInterface_getState(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_getState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_getStatePtr
newCallback_GameInterface_getState(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_getState<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_getState : public Callback_GameInterface_getState_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_GameInterface_getState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getState(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GameInterface_getStatePtr
newCallback_GameInterface_getState(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_getState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_getStatePtr
newCallback_GameInterface_getState(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_getState<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_getRoundCount : public Callback_GameInterface_getRoundCount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_GameInterface_getRoundCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getRoundCount(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GameInterface_getRoundCountPtr
newCallback_GameInterface_getRoundCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_getRoundCount<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_getRoundCountPtr
newCallback_GameInterface_getRoundCount(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_getRoundCount<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_getRoundCount : public Callback_GameInterface_getRoundCount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_GameInterface_getRoundCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getRoundCount(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GameInterface_getRoundCountPtr
newCallback_GameInterface_getRoundCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_getRoundCount<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_getRoundCountPtr
newCallback_GameInterface_getRoundCount(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_getRoundCount<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_setName : public Callback_GameInterface_setName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_setNamePtr
newCallback_GameInterface_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_setNamePtr
newCallback_GameInterface_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_setNamePtr
newCallback_GameInterface_setName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_setNamePtr
newCallback_GameInterface_setName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_setName : public Callback_GameInterface_setName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_setNamePtr
newCallback_GameInterface_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setNamePtr
newCallback_GameInterface_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setNamePtr
newCallback_GameInterface_setName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setNamePtr
newCallback_GameInterface_setName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_setState : public Callback_GameInterface_setState_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_setState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_setStatePtr
newCallback_GameInterface_setState(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_setStatePtr
newCallback_GameInterface_setState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setState<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_setStatePtr
newCallback_GameInterface_setState(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setState<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_setStatePtr
newCallback_GameInterface_setState(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setState<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_setState : public Callback_GameInterface_setState_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_setState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_setStatePtr
newCallback_GameInterface_setState(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setStatePtr
newCallback_GameInterface_setState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setState<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setStatePtr
newCallback_GameInterface_setState(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setState<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setStatePtr
newCallback_GameInterface_setState(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setState<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_setRoundCount : public Callback_GameInterface_setRoundCount_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_setRoundCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_setRoundCountPtr
newCallback_GameInterface_setRoundCount(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setRoundCount<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_setRoundCountPtr
newCallback_GameInterface_setRoundCount(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setRoundCount<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_setRoundCountPtr
newCallback_GameInterface_setRoundCount(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setRoundCount<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_setRoundCountPtr
newCallback_GameInterface_setRoundCount(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_setRoundCount<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_setRoundCount : public Callback_GameInterface_setRoundCount_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_setRoundCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_setRoundCountPtr
newCallback_GameInterface_setRoundCount(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setRoundCount<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setRoundCountPtr
newCallback_GameInterface_setRoundCount(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setRoundCount<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setRoundCountPtr
newCallback_GameInterface_setRoundCount(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setRoundCount<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_setRoundCountPtr
newCallback_GameInterface_setRoundCount(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_setRoundCount<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_kickPlayer : public Callback_GameInterface_kickPlayer_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_kickPlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_kickPlayerPtr
newCallback_GameInterface_kickPlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_kickPlayer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_kickPlayerPtr
newCallback_GameInterface_kickPlayer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_kickPlayer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_kickPlayerPtr
newCallback_GameInterface_kickPlayer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_kickPlayer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_kickPlayerPtr
newCallback_GameInterface_kickPlayer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_kickPlayer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_kickPlayer : public Callback_GameInterface_kickPlayer_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_kickPlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_kickPlayerPtr
newCallback_GameInterface_kickPlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_kickPlayer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_kickPlayerPtr
newCallback_GameInterface_kickPlayer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_kickPlayer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_kickPlayerPtr
newCallback_GameInterface_kickPlayer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_kickPlayer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_kickPlayerPtr
newCallback_GameInterface_kickPlayer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_kickPlayer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_invitePlayer : public Callback_GameInterface_invitePlayer_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_invitePlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_invitePlayerPtr
newCallback_GameInterface_invitePlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_invitePlayer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_invitePlayerPtr
newCallback_GameInterface_invitePlayer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_invitePlayer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_invitePlayerPtr
newCallback_GameInterface_invitePlayer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_invitePlayer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_invitePlayerPtr
newCallback_GameInterface_invitePlayer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_invitePlayer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_invitePlayer : public Callback_GameInterface_invitePlayer_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_invitePlayer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_invitePlayerPtr
newCallback_GameInterface_invitePlayer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_invitePlayer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_invitePlayerPtr
newCallback_GameInterface_invitePlayer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_invitePlayer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_invitePlayerPtr
newCallback_GameInterface_invitePlayer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_invitePlayer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_invitePlayerPtr
newCallback_GameInterface_invitePlayer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_invitePlayer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_addBot : public Callback_GameInterface_addBot_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_addBot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_addBotPtr
newCallback_GameInterface_addBot(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_addBot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_addBotPtr
newCallback_GameInterface_addBot(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_addBot<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_addBotPtr
newCallback_GameInterface_addBot(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_addBot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_addBotPtr
newCallback_GameInterface_addBot(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_addBot<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_addBot : public Callback_GameInterface_addBot_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_addBot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_addBotPtr
newCallback_GameInterface_addBot(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_addBot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_addBotPtr
newCallback_GameInterface_addBot(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_addBot<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_addBotPtr
newCallback_GameInterface_addBot(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_addBot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_addBotPtr
newCallback_GameInterface_addBot(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_addBot<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_removeBot : public Callback_GameInterface_removeBot_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_removeBot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_removeBotPtr
newCallback_GameInterface_removeBot(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_removeBot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_removeBotPtr
newCallback_GameInterface_removeBot(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_removeBot<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_removeBotPtr
newCallback_GameInterface_removeBot(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_removeBot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_removeBotPtr
newCallback_GameInterface_removeBot(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_removeBot<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_removeBot : public Callback_GameInterface_removeBot_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_removeBot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_removeBotPtr
newCallback_GameInterface_removeBot(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_removeBot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_removeBotPtr
newCallback_GameInterface_removeBot(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_removeBot<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_removeBotPtr
newCallback_GameInterface_removeBot(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_removeBot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_removeBotPtr
newCallback_GameInterface_removeBot(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_removeBot<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_createMap : public Callback_GameInterface_createMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_GameInterface_createMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_createMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GameInterface_createMapPtr
newCallback_GameInterface_createMap(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_createMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_createMapPtr
newCallback_GameInterface_createMap(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_createMap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_createMap : public Callback_GameInterface_createMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_GameInterface_createMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_createMap(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GameInterface_createMapPtr
newCallback_GameInterface_createMap(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_createMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_createMapPtr
newCallback_GameInterface_createMap(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_createMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_startMap : public Callback_GameInterface_startMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_startMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_startMapPtr
newCallback_GameInterface_startMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_startMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_startMapPtr
newCallback_GameInterface_startMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_startMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_startMapPtr
newCallback_GameInterface_startMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_startMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_startMapPtr
newCallback_GameInterface_startMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_startMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_startMap : public Callback_GameInterface_startMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_startMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_startMapPtr
newCallback_GameInterface_startMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_startMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_startMapPtr
newCallback_GameInterface_startMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_startMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_startMapPtr
newCallback_GameInterface_startMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_startMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_startMapPtr
newCallback_GameInterface_startMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_startMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_endMap : public Callback_GameInterface_endMap_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameInterface_endMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameInterface_endMapPtr
newCallback_GameInterface_endMap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_endMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_endMapPtr
newCallback_GameInterface_endMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_endMap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameInterface_endMapPtr
newCallback_GameInterface_endMap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_endMap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_endMapPtr
newCallback_GameInterface_endMap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_endMap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_endMap : public Callback_GameInterface_endMap_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameInterface_endMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameInterface_endMapPtr
newCallback_GameInterface_endMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_endMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_endMapPtr
newCallback_GameInterface_endMap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_endMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_endMapPtr
newCallback_GameInterface_endMap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_endMap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_endMapPtr
newCallback_GameInterface_endMap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_endMap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameInterface_removeGame : public Callback_GameInterface_removeGame_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_GameInterface_removeGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_removeGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_GameInterface_removeGamePtr
newCallback_GameInterface_removeGame(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_removeGame<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameInterface_removeGamePtr
newCallback_GameInterface_removeGame(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameInterface_removeGame<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameInterface_removeGame : public Callback_GameInterface_removeGame_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_GameInterface_removeGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::GameInterfacePrx __proxy = ::Bomberloutre::GameInterfacePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_removeGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_GameInterface_removeGamePtr
newCallback_GameInterface_removeGame(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_removeGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameInterface_removeGamePtr
newCallback_GameInterface_removeGame(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameInterface_removeGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_newUserInRoom : public Callback_GameWaitRoom_newUserInRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_newUserInRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_newUserInRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_newUserInRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_newUserInRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_newUserInRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_newUserInRoom : public Callback_GameWaitRoom_newUserInRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_newUserInRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_newUserInRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_newUserInRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_newUserInRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_newUserInRoomPtr
newCallback_GameWaitRoom_newUserInRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_newUserInRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_userLeftRoom : public Callback_GameWaitRoom_userLeftRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_userLeftRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userLeftRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userLeftRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userLeftRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userLeftRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_userLeftRoom : public Callback_GameWaitRoom_userLeftRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_userLeftRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userLeftRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userLeftRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userLeftRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userLeftRoomPtr
newCallback_GameWaitRoom_userLeftRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userLeftRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_allUsersReady : public Callback_GameWaitRoom_allUsersReady_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_allUsersReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_allUsersReady<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_allUsersReady<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_allUsersReady<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_allUsersReady<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_allUsersReady : public Callback_GameWaitRoom_allUsersReady_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_allUsersReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_allUsersReady<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_allUsersReady<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_allUsersReady<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_allUsersReadyPtr
newCallback_GameWaitRoom_allUsersReady(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_allUsersReady<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_userReady : public Callback_GameWaitRoom_userReady_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_userReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userReady<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userReady<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userReady<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_userReady<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_userReady : public Callback_GameWaitRoom_userReady_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_userReady(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userReady<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userReady<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userReady<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_userReadyPtr
newCallback_GameWaitRoom_userReady(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_userReady<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_gameStart : public Callback_GameWaitRoom_gameStart_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_gameStart(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_gameStartPtr
newCallback_GameWaitRoom_gameStart(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_gameStart<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_gameStartPtr
newCallback_GameWaitRoom_gameStart(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_gameStart<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_gameStartPtr
newCallback_GameWaitRoom_gameStart(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_gameStart<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_gameStartPtr
newCallback_GameWaitRoom_gameStart(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_gameStart<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_gameStart : public Callback_GameWaitRoom_gameStart_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_gameStart(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_gameStartPtr
newCallback_GameWaitRoom_gameStart(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_gameStart<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_gameStartPtr
newCallback_GameWaitRoom_gameStart(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_gameStart<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_gameStartPtr
newCallback_GameWaitRoom_gameStart(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_gameStart<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_gameStartPtr
newCallback_GameWaitRoom_gameStart(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_gameStart<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GameWaitRoom_gameEnd : public Callback_GameWaitRoom_gameEnd_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GameWaitRoom_gameEnd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_GameWaitRoom_gameEndPtr
newCallback_GameWaitRoom_gameEnd(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_gameEnd<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_gameEndPtr
newCallback_GameWaitRoom_gameEnd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_gameEnd<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_gameEndPtr
newCallback_GameWaitRoom_gameEnd(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_gameEnd<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GameWaitRoom_gameEndPtr
newCallback_GameWaitRoom_gameEnd(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GameWaitRoom_gameEnd<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GameWaitRoom_gameEnd : public Callback_GameWaitRoom_gameEnd_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GameWaitRoom_gameEnd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_GameWaitRoom_gameEndPtr
newCallback_GameWaitRoom_gameEnd(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_gameEnd<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_gameEndPtr
newCallback_GameWaitRoom_gameEnd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_gameEnd<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_gameEndPtr
newCallback_GameWaitRoom_gameEnd(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_gameEnd<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GameWaitRoom_gameEndPtr
newCallback_GameWaitRoom_gameEnd(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GameWaitRoom_gameEnd<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MapInterface_getId : public Callback_MapInterface_getId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_MapInterface_getId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::MapInterfacePrx __proxy = ::Bomberloutre::MapInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getId(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_MapInterface_getIdPtr
newCallback_MapInterface_getId(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_getId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapInterface_getIdPtr
newCallback_MapInterface_getId(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_getId<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapInterface_getId : public Callback_MapInterface_getId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_MapInterface_getId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::MapInterfacePrx __proxy = ::Bomberloutre::MapInterfacePrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getId(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MapInterface_getIdPtr
newCallback_MapInterface_getId(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_getId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_getIdPtr
newCallback_MapInterface_getId(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_getId<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MapInterface_getWidth : public Callback_MapInterface_getWidth_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_MapInterface_getWidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::MapInterfacePrx __proxy = ::Bomberloutre::MapInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getWidth(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_MapInterface_getWidthPtr
newCallback_MapInterface_getWidth(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_getWidth<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapInterface_getWidthPtr
newCallback_MapInterface_getWidth(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_getWidth<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapInterface_getWidth : public Callback_MapInterface_getWidth_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_MapInterface_getWidth(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::MapInterfacePrx __proxy = ::Bomberloutre::MapInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getWidth(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MapInterface_getWidthPtr
newCallback_MapInterface_getWidth(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_getWidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_getWidthPtr
newCallback_MapInterface_getWidth(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_getWidth<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MapInterface_getHeight : public Callback_MapInterface_getHeight_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_MapInterface_getHeight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::MapInterfacePrx __proxy = ::Bomberloutre::MapInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getHeight(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_MapInterface_getHeightPtr
newCallback_MapInterface_getHeight(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_getHeight<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapInterface_getHeightPtr
newCallback_MapInterface_getHeight(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_getHeight<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapInterface_getHeight : public Callback_MapInterface_getHeight_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_MapInterface_getHeight(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::MapInterfacePrx __proxy = ::Bomberloutre::MapInterfacePrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getHeight(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MapInterface_getHeightPtr
newCallback_MapInterface_getHeight(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_getHeight<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_getHeightPtr
newCallback_MapInterface_getHeight(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_getHeight<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MapInterface_move : public Callback_MapInterface_move_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_MapInterface_move(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::MapInterfacePrx __proxy = ::Bomberloutre::MapInterfacePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_move(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_MapInterface_movePtr
newCallback_MapInterface_move(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_move<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapInterface_movePtr
newCallback_MapInterface_move(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_move<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapInterface_move : public Callback_MapInterface_move_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_MapInterface_move(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::MapInterfacePrx __proxy = ::Bomberloutre::MapInterfacePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_move(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_MapInterface_movePtr
newCallback_MapInterface_move(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_move<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_movePtr
newCallback_MapInterface_move(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_move<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MapInterface_kickBomb : public Callback_MapInterface_kickBomb_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MapInterface_kickBomb(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MapInterface_kickBombPtr
newCallback_MapInterface_kickBomb(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_kickBomb<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapInterface_kickBombPtr
newCallback_MapInterface_kickBomb(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_kickBomb<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MapInterface_kickBombPtr
newCallback_MapInterface_kickBomb(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_kickBomb<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapInterface_kickBombPtr
newCallback_MapInterface_kickBomb(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_kickBomb<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapInterface_kickBomb : public Callback_MapInterface_kickBomb_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MapInterface_kickBomb(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MapInterface_kickBombPtr
newCallback_MapInterface_kickBomb(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_kickBomb<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_kickBombPtr
newCallback_MapInterface_kickBomb(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_kickBomb<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_kickBombPtr
newCallback_MapInterface_kickBomb(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_kickBomb<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_kickBombPtr
newCallback_MapInterface_kickBomb(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_kickBomb<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MapInterface_dropBomb : public Callback_MapInterface_dropBomb_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MapInterface_dropBomb(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MapInterface_dropBombPtr
newCallback_MapInterface_dropBomb(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_dropBomb<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapInterface_dropBombPtr
newCallback_MapInterface_dropBomb(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_dropBomb<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MapInterface_dropBombPtr
newCallback_MapInterface_dropBomb(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_dropBomb<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapInterface_dropBombPtr
newCallback_MapInterface_dropBomb(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapInterface_dropBomb<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapInterface_dropBomb : public Callback_MapInterface_dropBomb_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MapInterface_dropBomb(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MapInterface_dropBombPtr
newCallback_MapInterface_dropBomb(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_dropBomb<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_dropBombPtr
newCallback_MapInterface_dropBomb(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_dropBomb<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_dropBombPtr
newCallback_MapInterface_dropBomb(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_dropBomb<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapInterface_dropBombPtr
newCallback_MapInterface_dropBomb(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapInterface_dropBomb<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MapObserver_refreshMapItems : public Callback_MapObserver_refreshMapItems_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MapObserver_refreshMapItems(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MapObserver_refreshMapItemsPtr
newCallback_MapObserver_refreshMapItems(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_refreshMapItems<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_refreshMapItemsPtr
newCallback_MapObserver_refreshMapItems(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_refreshMapItems<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MapObserver_refreshMapItemsPtr
newCallback_MapObserver_refreshMapItems(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_refreshMapItems<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_refreshMapItemsPtr
newCallback_MapObserver_refreshMapItems(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_refreshMapItems<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapObserver_refreshMapItems : public Callback_MapObserver_refreshMapItems_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MapObserver_refreshMapItems(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MapObserver_refreshMapItemsPtr
newCallback_MapObserver_refreshMapItems(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_refreshMapItems<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_refreshMapItemsPtr
newCallback_MapObserver_refreshMapItems(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_refreshMapItems<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_refreshMapItemsPtr
newCallback_MapObserver_refreshMapItems(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_refreshMapItems<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_refreshMapItemsPtr
newCallback_MapObserver_refreshMapItems(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_refreshMapItems<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MapObserver_refreshPlayers : public Callback_MapObserver_refreshPlayers_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MapObserver_refreshPlayers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MapObserver_refreshPlayersPtr
newCallback_MapObserver_refreshPlayers(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_refreshPlayers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_refreshPlayersPtr
newCallback_MapObserver_refreshPlayers(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_refreshPlayers<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MapObserver_refreshPlayersPtr
newCallback_MapObserver_refreshPlayers(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_refreshPlayers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_refreshPlayersPtr
newCallback_MapObserver_refreshPlayers(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_refreshPlayers<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapObserver_refreshPlayers : public Callback_MapObserver_refreshPlayers_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MapObserver_refreshPlayers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MapObserver_refreshPlayersPtr
newCallback_MapObserver_refreshPlayers(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_refreshPlayers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_refreshPlayersPtr
newCallback_MapObserver_refreshPlayers(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_refreshPlayers<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_refreshPlayersPtr
newCallback_MapObserver_refreshPlayers(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_refreshPlayers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_refreshPlayersPtr
newCallback_MapObserver_refreshPlayers(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_refreshPlayers<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MapObserver_bombHasBeenPlanted : public Callback_MapObserver_bombHasBeenPlanted_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MapObserver_bombHasBeenPlanted(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MapObserver_bombHasBeenPlantedPtr
newCallback_MapObserver_bombHasBeenPlanted(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bombHasBeenPlanted<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_bombHasBeenPlantedPtr
newCallback_MapObserver_bombHasBeenPlanted(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bombHasBeenPlanted<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MapObserver_bombHasBeenPlantedPtr
newCallback_MapObserver_bombHasBeenPlanted(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bombHasBeenPlanted<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_bombHasBeenPlantedPtr
newCallback_MapObserver_bombHasBeenPlanted(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bombHasBeenPlanted<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapObserver_bombHasBeenPlanted : public Callback_MapObserver_bombHasBeenPlanted_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MapObserver_bombHasBeenPlanted(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MapObserver_bombHasBeenPlantedPtr
newCallback_MapObserver_bombHasBeenPlanted(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bombHasBeenPlanted<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bombHasBeenPlantedPtr
newCallback_MapObserver_bombHasBeenPlanted(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bombHasBeenPlanted<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bombHasBeenPlantedPtr
newCallback_MapObserver_bombHasBeenPlanted(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bombHasBeenPlanted<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bombHasBeenPlantedPtr
newCallback_MapObserver_bombHasBeenPlanted(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bombHasBeenPlanted<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MapObserver_bombExploded : public Callback_MapObserver_bombExploded_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MapObserver_bombExploded(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MapObserver_bombExplodedPtr
newCallback_MapObserver_bombExploded(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bombExploded<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_bombExplodedPtr
newCallback_MapObserver_bombExploded(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bombExploded<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MapObserver_bombExplodedPtr
newCallback_MapObserver_bombExploded(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bombExploded<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_bombExplodedPtr
newCallback_MapObserver_bombExploded(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bombExploded<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapObserver_bombExploded : public Callback_MapObserver_bombExploded_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MapObserver_bombExploded(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MapObserver_bombExplodedPtr
newCallback_MapObserver_bombExploded(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bombExploded<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bombExplodedPtr
newCallback_MapObserver_bombExploded(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bombExploded<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bombExplodedPtr
newCallback_MapObserver_bombExploded(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bombExploded<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bombExplodedPtr
newCallback_MapObserver_bombExploded(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bombExploded<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MapObserver_bonusesDropped : public Callback_MapObserver_bonusesDropped_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MapObserver_bonusesDropped(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MapObserver_bonusesDroppedPtr
newCallback_MapObserver_bonusesDropped(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bonusesDropped<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_bonusesDroppedPtr
newCallback_MapObserver_bonusesDropped(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bonusesDropped<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MapObserver_bonusesDroppedPtr
newCallback_MapObserver_bonusesDropped(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bonusesDropped<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MapObserver_bonusesDroppedPtr
newCallback_MapObserver_bonusesDropped(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MapObserver_bonusesDropped<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MapObserver_bonusesDropped : public Callback_MapObserver_bonusesDropped_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MapObserver_bonusesDropped(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MapObserver_bonusesDroppedPtr
newCallback_MapObserver_bonusesDropped(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bonusesDropped<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bonusesDroppedPtr
newCallback_MapObserver_bonusesDropped(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bonusesDropped<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bonusesDroppedPtr
newCallback_MapObserver_bonusesDropped(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bonusesDropped<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MapObserver_bonusesDroppedPtr
newCallback_MapObserver_bonusesDropped(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MapObserver_bonusesDropped<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ServerInterface_connect : public Callback_ServerInterface_connect_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::UserData&);

    CallbackNC_ServerInterface_connect(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::UserData __ret;
        try
        {
            __ret = __proxy->end_connect(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerInterface_connectPtr
newCallback_ServerInterface_connect(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::UserData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_connect<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerInterface_connectPtr
newCallback_ServerInterface_connect(T* instance, void (T::*cb)(const ::Bomberloutre::UserData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_connect<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerInterface_connect : public Callback_ServerInterface_connect_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::UserData&, const CT&);

    Callback_ServerInterface_connect(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::UserData __ret;
        try
        {
            __ret = __proxy->end_connect(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerInterface_connectPtr
newCallback_ServerInterface_connect(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::UserData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_connect<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerInterface_connectPtr
newCallback_ServerInterface_connect(T* instance, void (T::*cb)(const ::Bomberloutre::UserData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_connect<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerInterface_createUser : public Callback_ServerInterface_createUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::UserData&);

    CallbackNC_ServerInterface_createUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::UserData __ret;
        try
        {
            __ret = __proxy->end_createUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerInterface_createUserPtr
newCallback_ServerInterface_createUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::UserData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_createUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerInterface_createUserPtr
newCallback_ServerInterface_createUser(T* instance, void (T::*cb)(const ::Bomberloutre::UserData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_createUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerInterface_createUser : public Callback_ServerInterface_createUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::UserData&, const CT&);

    Callback_ServerInterface_createUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::UserData __ret;
        try
        {
            __ret = __proxy->end_createUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerInterface_createUserPtr
newCallback_ServerInterface_createUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::UserData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_createUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerInterface_createUserPtr
newCallback_ServerInterface_createUser(T* instance, void (T::*cb)(const ::Bomberloutre::UserData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_createUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerInterface_deleteUser : public Callback_ServerInterface_deleteUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ServerInterface_deleteUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_deleteUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerInterface_deleteUserPtr
newCallback_ServerInterface_deleteUser(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_deleteUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerInterface_deleteUserPtr
newCallback_ServerInterface_deleteUser(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_deleteUser<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerInterface_deleteUser : public Callback_ServerInterface_deleteUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ServerInterface_deleteUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_deleteUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerInterface_deleteUserPtr
newCallback_ServerInterface_deleteUser(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_deleteUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerInterface_deleteUserPtr
newCallback_ServerInterface_deleteUser(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_deleteUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerInterface_addGame : public Callback_ServerInterface_addGame_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::GameInterfacePrx&);

    CallbackNC_ServerInterface_addGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::GameInterfacePrx __ret;
        try
        {
            __ret = __proxy->end_addGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerInterface_addGamePtr
newCallback_ServerInterface_addGame(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::GameInterfacePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_addGame<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerInterface_addGamePtr
newCallback_ServerInterface_addGame(T* instance, void (T::*cb)(const ::Bomberloutre::GameInterfacePrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_addGame<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerInterface_addGame : public Callback_ServerInterface_addGame_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::GameInterfacePrx&, const CT&);

    Callback_ServerInterface_addGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::GameInterfacePrx __ret;
        try
        {
            __ret = __proxy->end_addGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerInterface_addGamePtr
newCallback_ServerInterface_addGame(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::GameInterfacePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_addGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerInterface_addGamePtr
newCallback_ServerInterface_addGame(T* instance, void (T::*cb)(const ::Bomberloutre::GameInterfacePrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_addGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerInterface_joinGame : public Callback_ServerInterface_joinGame_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::Map&);

    CallbackNC_ServerInterface_joinGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::Map __ret;
        try
        {
            __ret = __proxy->end_joinGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerInterface_joinGamePtr
newCallback_ServerInterface_joinGame(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::Map&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_joinGame<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerInterface_joinGamePtr
newCallback_ServerInterface_joinGame(T* instance, void (T::*cb)(const ::Bomberloutre::Map&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_joinGame<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerInterface_joinGame : public Callback_ServerInterface_joinGame_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::Map&, const CT&);

    Callback_ServerInterface_joinGame(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::Map __ret;
        try
        {
            __ret = __proxy->end_joinGame(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerInterface_joinGamePtr
newCallback_ServerInterface_joinGame(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::Map&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_joinGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerInterface_joinGamePtr
newCallback_ServerInterface_joinGame(T* instance, void (T::*cb)(const ::Bomberloutre::Map&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_joinGame<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerInterface_getGameList : public Callback_ServerInterface_getGameList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::GameDataList&);

    CallbackNC_ServerInterface_getGameList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::GameDataList __ret;
        try
        {
            __ret = __proxy->end_getGameList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerInterface_getGameListPtr
newCallback_ServerInterface_getGameList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::GameDataList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_getGameList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerInterface_getGameListPtr
newCallback_ServerInterface_getGameList(T* instance, void (T::*cb)(const ::Bomberloutre::GameDataList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_getGameList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerInterface_getGameList : public Callback_ServerInterface_getGameList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::GameDataList&, const CT&);

    Callback_ServerInterface_getGameList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::GameDataList __ret;
        try
        {
            __ret = __proxy->end_getGameList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerInterface_getGameListPtr
newCallback_ServerInterface_getGameList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::GameDataList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_getGameList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerInterface_getGameListPtr
newCallback_ServerInterface_getGameList(T* instance, void (T::*cb)(const ::Bomberloutre::GameDataList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_getGameList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ServerInterface_getUserList : public Callback_ServerInterface_getUserList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Bomberloutre::UserDataList&);

    CallbackNC_ServerInterface_getUserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::UserDataList __ret;
        try
        {
            __ret = __proxy->end_getUserList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_ServerInterface_getUserListPtr
newCallback_ServerInterface_getUserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::UserDataList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_getUserList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ServerInterface_getUserListPtr
newCallback_ServerInterface_getUserList(T* instance, void (T::*cb)(const ::Bomberloutre::UserDataList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerInterface_getUserList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ServerInterface_getUserList : public Callback_ServerInterface_getUserList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Bomberloutre::UserDataList&, const CT&);

    Callback_ServerInterface_getUserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Bomberloutre::ServerInterfacePrx __proxy = ::Bomberloutre::ServerInterfacePrx::uncheckedCast(__result->getProxy());
        ::Bomberloutre::UserDataList __ret;
        try
        {
            __ret = __proxy->end_getUserList(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ServerInterface_getUserListPtr
newCallback_ServerInterface_getUserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Bomberloutre::UserDataList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_getUserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ServerInterface_getUserListPtr
newCallback_ServerInterface_getUserList(T* instance, void (T::*cb)(const ::Bomberloutre::UserDataList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerInterface_getUserList<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
