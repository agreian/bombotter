// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Bomberloutre_object.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Bomberloutre_object.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

::Ice::Object* IceInternal::upCast(::Bomberloutre::MapItem* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::MapItem* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::Bomb* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::Bomb* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::Empty* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::Empty* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::Box* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::Box* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::Rock* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::Rock* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::Bonus* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::Bonus* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::Kicker* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::Kicker* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::FlameUp* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::FlameUp* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::SpeedUp* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::SpeedUp* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::BombUp* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::BombUp* p) { return p; }

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::MapItemPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::MapItem;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::BombPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::Bomb;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::EmptyPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::Empty;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::BoxPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::Box;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::RockPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::Rock;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::BonusPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::Bonus;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::KickerPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::Kicker;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::FlameUpPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::FlameUp;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::SpeedUpPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::SpeedUp;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::BombUpPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::BombUp;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__writeMapItems(::IceInternal::BasicStream* __os, const ::Bomberloutre::MapItemPtr* begin, const ::Bomberloutre::MapItemPtr* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(begin[i].get())));
    }
}

void
Bomberloutre::__readMapItems(::IceInternal::BasicStream* __is, ::Bomberloutre::MapItems& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(4, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __is->read(::Bomberloutre::__patch__MapItemPtr, &v[i]);
    }
}

void
Bomberloutre::__writeBombs(::IceInternal::BasicStream* __os, const ::Bomberloutre::BombPtr* begin, const ::Bomberloutre::BombPtr* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(begin[i].get())));
    }
}

void
Bomberloutre::__readBombs(::IceInternal::BasicStream* __is, ::Bomberloutre::Bombs& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(4, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __is->read(::Bomberloutre::__patch__BombPtr, &v[i]);
    }
}

void
Bomberloutre::__writeBonuses(::IceInternal::BasicStream* __os, const ::Bomberloutre::BonusPtr* begin, const ::Bomberloutre::BonusPtr* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(begin[i].get())));
    }
}

void
Bomberloutre::__readBonuses(::IceInternal::BasicStream* __is, ::Bomberloutre::Bonuses& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(4, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        __is->read(::Bomberloutre::__patch__BonusPtr, &v[i]);
    }
}

const ::std::string&
IceProxy::Bomberloutre::MapItem::ice_staticId()
{
    return ::Bomberloutre::MapItem::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::MapItem::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::MapItem);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::MapItem::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::MapItem);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::MapItem::__newInstance() const
{
    return new MapItem;
}

const ::std::string&
IceProxy::Bomberloutre::Bomb::ice_staticId()
{
    return ::Bomberloutre::Bomb::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::Bomb::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::Bomb);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::Bomb::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::Bomb);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::Bomb::__newInstance() const
{
    return new Bomb;
}

const ::std::string&
IceProxy::Bomberloutre::Empty::ice_staticId()
{
    return ::Bomberloutre::Empty::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::Empty::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::Empty);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::Empty::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::Empty);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::Empty::__newInstance() const
{
    return new Empty;
}

const ::std::string&
IceProxy::Bomberloutre::Box::ice_staticId()
{
    return ::Bomberloutre::Box::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::Box::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::Box);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::Box::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::Box);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::Box::__newInstance() const
{
    return new Box;
}

const ::std::string&
IceProxy::Bomberloutre::Rock::ice_staticId()
{
    return ::Bomberloutre::Rock::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::Rock::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::Rock);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::Rock::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::Rock);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::Rock::__newInstance() const
{
    return new Rock;
}

const ::std::string&
IceProxy::Bomberloutre::Bonus::ice_staticId()
{
    return ::Bomberloutre::Bonus::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::Bonus::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::Bonus);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::Bonus::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::Bonus);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::Bonus::__newInstance() const
{
    return new Bonus;
}

const ::std::string&
IceProxy::Bomberloutre::Kicker::ice_staticId()
{
    return ::Bomberloutre::Kicker::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::Kicker::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::Kicker);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::Kicker::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::Kicker);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::Kicker::__newInstance() const
{
    return new Kicker;
}

const ::std::string&
IceProxy::Bomberloutre::FlameUp::ice_staticId()
{
    return ::Bomberloutre::FlameUp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::FlameUp::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::FlameUp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::FlameUp::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::FlameUp);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::FlameUp::__newInstance() const
{
    return new FlameUp;
}

const ::std::string&
IceProxy::Bomberloutre::SpeedUp::ice_staticId()
{
    return ::Bomberloutre::SpeedUp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::SpeedUp::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::SpeedUp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::SpeedUp::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::SpeedUp);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::SpeedUp::__newInstance() const
{
    return new SpeedUp;
}

const ::std::string&
IceProxy::Bomberloutre::BombUp::ice_staticId()
{
    return ::Bomberloutre::BombUp::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::BombUp::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::BombUp);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::BombUp::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::BombUp);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::BombUp::__newInstance() const
{
    return new BombUp;
}

Bomberloutre::MapItem::MapItem(bool __ice_destructible, bool __ice_walkable) :
    destructible(__ice_destructible),
    walkable(__ice_walkable)
{
}

::Ice::ObjectPtr
Bomberloutre::MapItem::ice_clone() const
{
    ::Bomberloutre::MapItemPtr __p = new ::Bomberloutre::MapItem(*this);
    return __p;
}

static const ::std::string __Bomberloutre__MapItem_ids[2] =
{
    "::Bomberloutre::MapItem",
    "::Ice::Object"
};

bool
Bomberloutre::MapItem::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__MapItem_ids, __Bomberloutre__MapItem_ids + 2, _s);
}

::std::vector< ::std::string>
Bomberloutre::MapItem::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__MapItem_ids[0], &__Bomberloutre__MapItem_ids[2]);
}

const ::std::string&
Bomberloutre::MapItem::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__MapItem_ids[0];
}

const ::std::string&
Bomberloutre::MapItem::ice_staticId()
{
    return __Bomberloutre__MapItem_ids[0];
}

void
Bomberloutre::MapItem::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(destructible);
    __os->write(walkable);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
Bomberloutre::MapItem::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(destructible);
    __is->read(walkable);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::MapItem::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::MapItem was not generated with stream support";
    throw ex;
}

void
Bomberloutre::MapItem::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::MapItem was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__MapItem : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::MapItem::ice_staticId());
        return new ::Bomberloutre::MapItem;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__MapItem_Ptr = new __F__Bomberloutre__MapItem;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::MapItem::ice_factory()
{
    return __F__Bomberloutre__MapItem_Ptr;
}

class __F__Bomberloutre__MapItem__Init
{
public:

    __F__Bomberloutre__MapItem__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::MapItem::ice_staticId(), ::Bomberloutre::MapItem::ice_factory());
    }

    ~__F__Bomberloutre__MapItem__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::MapItem::ice_staticId());
    }
};

static __F__Bomberloutre__MapItem__Init __F__Bomberloutre__MapItem__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__MapItem__initializer() {} }
#endif

void 
Bomberloutre::__patch__MapItemPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::MapItemPtr* p = static_cast< ::Bomberloutre::MapItemPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::MapItemPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::MapItem::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::Bomb::Bomb(bool __ice_destructible, bool __ice_walkable, ::Ice::Int __ice_power, ::Ice::Int __ice_timer) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem(__ice_destructible, __ice_walkable)
#else
    ::Bomberloutre::MapItem(__ice_destructible, __ice_walkable)
#endif
,
    power(__ice_power),
    timer(__ice_timer)
{
}

::Ice::ObjectPtr
Bomberloutre::Bomb::ice_clone() const
{
    ::Bomberloutre::BombPtr __p = new ::Bomberloutre::Bomb(*this);
    return __p;
}

static const ::std::string __Bomberloutre__Bomb_ids[3] =
{
    "::Bomberloutre::Bomb",
    "::Bomberloutre::MapItem",
    "::Ice::Object"
};

bool
Bomberloutre::Bomb::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__Bomb_ids, __Bomberloutre__Bomb_ids + 3, _s);
}

::std::vector< ::std::string>
Bomberloutre::Bomb::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__Bomb_ids[0], &__Bomberloutre__Bomb_ids[3]);
}

const ::std::string&
Bomberloutre::Bomb::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__Bomb_ids[0];
}

const ::std::string&
Bomberloutre::Bomb::ice_staticId()
{
    return __Bomberloutre__Bomb_ids[0];
}

void
Bomberloutre::Bomb::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(power);
    __os->write(timer);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__write(__os);
#else
    ::Bomberloutre::MapItem::__write(__os);
#endif
}

void
Bomberloutre::Bomb::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(power);
    __is->read(timer);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__read(__is, true);
#else
    ::Bomberloutre::MapItem::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::Bomb::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Bomb was not generated with stream support";
    throw ex;
}

void
Bomberloutre::Bomb::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Bomb was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__Bomb : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::Bomb::ice_staticId());
        return new ::Bomberloutre::Bomb;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__Bomb_Ptr = new __F__Bomberloutre__Bomb;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::Bomb::ice_factory()
{
    return __F__Bomberloutre__Bomb_Ptr;
}

class __F__Bomberloutre__Bomb__Init
{
public:

    __F__Bomberloutre__Bomb__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::Bomb::ice_staticId(), ::Bomberloutre::Bomb::ice_factory());
    }

    ~__F__Bomberloutre__Bomb__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::Bomb::ice_staticId());
    }
};

static __F__Bomberloutre__Bomb__Init __F__Bomberloutre__Bomb__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__Bomb__initializer() {} }
#endif

void 
Bomberloutre::__patch__BombPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::BombPtr* p = static_cast< ::Bomberloutre::BombPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::BombPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::Bomb::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::Empty::Empty(bool __ice_destructible, bool __ice_walkable) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem(__ice_destructible, __ice_walkable)
#else
    ::Bomberloutre::MapItem(__ice_destructible, __ice_walkable)
#endif

{
}

::Ice::ObjectPtr
Bomberloutre::Empty::ice_clone() const
{
    ::Bomberloutre::EmptyPtr __p = new ::Bomberloutre::Empty(*this);
    return __p;
}

static const ::std::string __Bomberloutre__Empty_ids[3] =
{
    "::Bomberloutre::Empty",
    "::Bomberloutre::MapItem",
    "::Ice::Object"
};

bool
Bomberloutre::Empty::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__Empty_ids, __Bomberloutre__Empty_ids + 3, _s);
}

::std::vector< ::std::string>
Bomberloutre::Empty::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__Empty_ids[0], &__Bomberloutre__Empty_ids[3]);
}

const ::std::string&
Bomberloutre::Empty::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__Empty_ids[0];
}

const ::std::string&
Bomberloutre::Empty::ice_staticId()
{
    return __Bomberloutre__Empty_ids[0];
}

void
Bomberloutre::Empty::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__write(__os);
#else
    ::Bomberloutre::MapItem::__write(__os);
#endif
}

void
Bomberloutre::Empty::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__read(__is, true);
#else
    ::Bomberloutre::MapItem::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::Empty::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Empty was not generated with stream support";
    throw ex;
}

void
Bomberloutre::Empty::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Empty was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__Empty : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::Empty::ice_staticId());
        return new ::Bomberloutre::Empty;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__Empty_Ptr = new __F__Bomberloutre__Empty;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::Empty::ice_factory()
{
    return __F__Bomberloutre__Empty_Ptr;
}

class __F__Bomberloutre__Empty__Init
{
public:

    __F__Bomberloutre__Empty__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::Empty::ice_staticId(), ::Bomberloutre::Empty::ice_factory());
    }

    ~__F__Bomberloutre__Empty__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::Empty::ice_staticId());
    }
};

static __F__Bomberloutre__Empty__Init __F__Bomberloutre__Empty__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__Empty__initializer() {} }
#endif

void 
Bomberloutre::__patch__EmptyPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::EmptyPtr* p = static_cast< ::Bomberloutre::EmptyPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::EmptyPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::Empty::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::Box::Box(bool __ice_destructible, bool __ice_walkable) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem(__ice_destructible, __ice_walkable)
#else
    ::Bomberloutre::MapItem(__ice_destructible, __ice_walkable)
#endif

{
}

::Ice::ObjectPtr
Bomberloutre::Box::ice_clone() const
{
    ::Bomberloutre::BoxPtr __p = new ::Bomberloutre::Box(*this);
    return __p;
}

static const ::std::string __Bomberloutre__Box_ids[3] =
{
    "::Bomberloutre::Box",
    "::Bomberloutre::MapItem",
    "::Ice::Object"
};

bool
Bomberloutre::Box::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__Box_ids, __Bomberloutre__Box_ids + 3, _s);
}

::std::vector< ::std::string>
Bomberloutre::Box::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__Box_ids[0], &__Bomberloutre__Box_ids[3]);
}

const ::std::string&
Bomberloutre::Box::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__Box_ids[0];
}

const ::std::string&
Bomberloutre::Box::ice_staticId()
{
    return __Bomberloutre__Box_ids[0];
}

void
Bomberloutre::Box::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__write(__os);
#else
    ::Bomberloutre::MapItem::__write(__os);
#endif
}

void
Bomberloutre::Box::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__read(__is, true);
#else
    ::Bomberloutre::MapItem::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::Box::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Box was not generated with stream support";
    throw ex;
}

void
Bomberloutre::Box::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Box was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__Box : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::Box::ice_staticId());
        return new ::Bomberloutre::Box;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__Box_Ptr = new __F__Bomberloutre__Box;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::Box::ice_factory()
{
    return __F__Bomberloutre__Box_Ptr;
}

class __F__Bomberloutre__Box__Init
{
public:

    __F__Bomberloutre__Box__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::Box::ice_staticId(), ::Bomberloutre::Box::ice_factory());
    }

    ~__F__Bomberloutre__Box__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::Box::ice_staticId());
    }
};

static __F__Bomberloutre__Box__Init __F__Bomberloutre__Box__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__Box__initializer() {} }
#endif

void 
Bomberloutre::__patch__BoxPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::BoxPtr* p = static_cast< ::Bomberloutre::BoxPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::BoxPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::Box::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::Rock::Rock(bool __ice_destructible, bool __ice_walkable) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem(__ice_destructible, __ice_walkable)
#else
    ::Bomberloutre::MapItem(__ice_destructible, __ice_walkable)
#endif

{
}

::Ice::ObjectPtr
Bomberloutre::Rock::ice_clone() const
{
    ::Bomberloutre::RockPtr __p = new ::Bomberloutre::Rock(*this);
    return __p;
}

static const ::std::string __Bomberloutre__Rock_ids[3] =
{
    "::Bomberloutre::MapItem",
    "::Bomberloutre::Rock",
    "::Ice::Object"
};

bool
Bomberloutre::Rock::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__Rock_ids, __Bomberloutre__Rock_ids + 3, _s);
}

::std::vector< ::std::string>
Bomberloutre::Rock::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__Rock_ids[0], &__Bomberloutre__Rock_ids[3]);
}

const ::std::string&
Bomberloutre::Rock::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__Rock_ids[1];
}

const ::std::string&
Bomberloutre::Rock::ice_staticId()
{
    return __Bomberloutre__Rock_ids[1];
}

void
Bomberloutre::Rock::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__write(__os);
#else
    ::Bomberloutre::MapItem::__write(__os);
#endif
}

void
Bomberloutre::Rock::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__read(__is, true);
#else
    ::Bomberloutre::MapItem::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::Rock::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Rock was not generated with stream support";
    throw ex;
}

void
Bomberloutre::Rock::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Rock was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__Rock : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::Rock::ice_staticId());
        return new ::Bomberloutre::Rock;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__Rock_Ptr = new __F__Bomberloutre__Rock;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::Rock::ice_factory()
{
    return __F__Bomberloutre__Rock_Ptr;
}

class __F__Bomberloutre__Rock__Init
{
public:

    __F__Bomberloutre__Rock__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::Rock::ice_staticId(), ::Bomberloutre::Rock::ice_factory());
    }

    ~__F__Bomberloutre__Rock__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::Rock::ice_staticId());
    }
};

static __F__Bomberloutre__Rock__Init __F__Bomberloutre__Rock__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__Rock__initializer() {} }
#endif

void 
Bomberloutre::__patch__RockPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::RockPtr* p = static_cast< ::Bomberloutre::RockPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::RockPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::Rock::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::Bonus::Bonus(bool __ice_destructible, bool __ice_walkable, ::Ice::Int __ice_bomb, bool __ice_kick, ::Ice::Int __ice_power, ::Ice::Int __ice_speed) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem(__ice_destructible, __ice_walkable)
#else
    ::Bomberloutre::MapItem(__ice_destructible, __ice_walkable)
#endif
,
    bomb(__ice_bomb),
    kick(__ice_kick),
    power(__ice_power),
    speed(__ice_speed)
{
}

::Ice::ObjectPtr
Bomberloutre::Bonus::ice_clone() const
{
    ::Bomberloutre::BonusPtr __p = new ::Bomberloutre::Bonus(*this);
    return __p;
}

static const ::std::string __Bomberloutre__Bonus_ids[3] =
{
    "::Bomberloutre::Bonus",
    "::Bomberloutre::MapItem",
    "::Ice::Object"
};

bool
Bomberloutre::Bonus::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__Bonus_ids, __Bomberloutre__Bonus_ids + 3, _s);
}

::std::vector< ::std::string>
Bomberloutre::Bonus::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__Bonus_ids[0], &__Bomberloutre__Bonus_ids[3]);
}

const ::std::string&
Bomberloutre::Bonus::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__Bonus_ids[0];
}

const ::std::string&
Bomberloutre::Bonus::ice_staticId()
{
    return __Bomberloutre__Bonus_ids[0];
}

void
Bomberloutre::Bonus::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->write(bomb);
    __os->write(kick);
    __os->write(power);
    __os->write(speed);
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__write(__os);
#else
    ::Bomberloutre::MapItem::__write(__os);
#endif
}

void
Bomberloutre::Bonus::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->read(bomb);
    __is->read(kick);
    __is->read(power);
    __is->read(speed);
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    MapItem::__read(__is, true);
#else
    ::Bomberloutre::MapItem::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::Bonus::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Bonus was not generated with stream support";
    throw ex;
}

void
Bomberloutre::Bonus::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Bonus was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__Bonus : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::Bonus::ice_staticId());
        return new ::Bomberloutre::Bonus;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__Bonus_Ptr = new __F__Bomberloutre__Bonus;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::Bonus::ice_factory()
{
    return __F__Bomberloutre__Bonus_Ptr;
}

class __F__Bomberloutre__Bonus__Init
{
public:

    __F__Bomberloutre__Bonus__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::Bonus::ice_staticId(), ::Bomberloutre::Bonus::ice_factory());
    }

    ~__F__Bomberloutre__Bonus__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::Bonus::ice_staticId());
    }
};

static __F__Bomberloutre__Bonus__Init __F__Bomberloutre__Bonus__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__Bonus__initializer() {} }
#endif

void 
Bomberloutre::__patch__BonusPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::BonusPtr* p = static_cast< ::Bomberloutre::BonusPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::BonusPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::Bonus::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::Kicker::Kicker(bool __ice_destructible, bool __ice_walkable, ::Ice::Int __ice_bomb, bool __ice_kick, ::Ice::Int __ice_power, ::Ice::Int __ice_speed) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus(__ice_destructible, __ice_walkable, __ice_bomb, __ice_kick, __ice_power, __ice_speed)
#else
    ::Bomberloutre::Bonus(__ice_destructible, __ice_walkable, __ice_bomb, __ice_kick, __ice_power, __ice_speed)
#endif

{
}

::Ice::ObjectPtr
Bomberloutre::Kicker::ice_clone() const
{
    ::Bomberloutre::KickerPtr __p = new ::Bomberloutre::Kicker(*this);
    return __p;
}

static const ::std::string __Bomberloutre__Kicker_ids[4] =
{
    "::Bomberloutre::Bonus",
    "::Bomberloutre::Kicker",
    "::Bomberloutre::MapItem",
    "::Ice::Object"
};

bool
Bomberloutre::Kicker::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__Kicker_ids, __Bomberloutre__Kicker_ids + 4, _s);
}

::std::vector< ::std::string>
Bomberloutre::Kicker::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__Kicker_ids[0], &__Bomberloutre__Kicker_ids[4]);
}

const ::std::string&
Bomberloutre::Kicker::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__Kicker_ids[1];
}

const ::std::string&
Bomberloutre::Kicker::ice_staticId()
{
    return __Bomberloutre__Kicker_ids[1];
}

void
Bomberloutre::Kicker::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus::__write(__os);
#else
    ::Bomberloutre::Bonus::__write(__os);
#endif
}

void
Bomberloutre::Kicker::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus::__read(__is, true);
#else
    ::Bomberloutre::Bonus::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::Kicker::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Kicker was not generated with stream support";
    throw ex;
}

void
Bomberloutre::Kicker::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::Kicker was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__Kicker : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::Kicker::ice_staticId());
        return new ::Bomberloutre::Kicker;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__Kicker_Ptr = new __F__Bomberloutre__Kicker;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::Kicker::ice_factory()
{
    return __F__Bomberloutre__Kicker_Ptr;
}

class __F__Bomberloutre__Kicker__Init
{
public:

    __F__Bomberloutre__Kicker__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::Kicker::ice_staticId(), ::Bomberloutre::Kicker::ice_factory());
    }

    ~__F__Bomberloutre__Kicker__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::Kicker::ice_staticId());
    }
};

static __F__Bomberloutre__Kicker__Init __F__Bomberloutre__Kicker__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__Kicker__initializer() {} }
#endif

void 
Bomberloutre::__patch__KickerPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::KickerPtr* p = static_cast< ::Bomberloutre::KickerPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::KickerPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::Kicker::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::FlameUp::FlameUp(bool __ice_destructible, bool __ice_walkable, ::Ice::Int __ice_bomb, bool __ice_kick, ::Ice::Int __ice_power, ::Ice::Int __ice_speed) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus(__ice_destructible, __ice_walkable, __ice_bomb, __ice_kick, __ice_power, __ice_speed)
#else
    ::Bomberloutre::Bonus(__ice_destructible, __ice_walkable, __ice_bomb, __ice_kick, __ice_power, __ice_speed)
#endif

{
}

::Ice::ObjectPtr
Bomberloutre::FlameUp::ice_clone() const
{
    ::Bomberloutre::FlameUpPtr __p = new ::Bomberloutre::FlameUp(*this);
    return __p;
}

static const ::std::string __Bomberloutre__FlameUp_ids[4] =
{
    "::Bomberloutre::Bonus",
    "::Bomberloutre::FlameUp",
    "::Bomberloutre::MapItem",
    "::Ice::Object"
};

bool
Bomberloutre::FlameUp::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__FlameUp_ids, __Bomberloutre__FlameUp_ids + 4, _s);
}

::std::vector< ::std::string>
Bomberloutre::FlameUp::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__FlameUp_ids[0], &__Bomberloutre__FlameUp_ids[4]);
}

const ::std::string&
Bomberloutre::FlameUp::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__FlameUp_ids[1];
}

const ::std::string&
Bomberloutre::FlameUp::ice_staticId()
{
    return __Bomberloutre__FlameUp_ids[1];
}

void
Bomberloutre::FlameUp::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus::__write(__os);
#else
    ::Bomberloutre::Bonus::__write(__os);
#endif
}

void
Bomberloutre::FlameUp::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus::__read(__is, true);
#else
    ::Bomberloutre::Bonus::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::FlameUp::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::FlameUp was not generated with stream support";
    throw ex;
}

void
Bomberloutre::FlameUp::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::FlameUp was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__FlameUp : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::FlameUp::ice_staticId());
        return new ::Bomberloutre::FlameUp;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__FlameUp_Ptr = new __F__Bomberloutre__FlameUp;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::FlameUp::ice_factory()
{
    return __F__Bomberloutre__FlameUp_Ptr;
}

class __F__Bomberloutre__FlameUp__Init
{
public:

    __F__Bomberloutre__FlameUp__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::FlameUp::ice_staticId(), ::Bomberloutre::FlameUp::ice_factory());
    }

    ~__F__Bomberloutre__FlameUp__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::FlameUp::ice_staticId());
    }
};

static __F__Bomberloutre__FlameUp__Init __F__Bomberloutre__FlameUp__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__FlameUp__initializer() {} }
#endif

void 
Bomberloutre::__patch__FlameUpPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::FlameUpPtr* p = static_cast< ::Bomberloutre::FlameUpPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::FlameUpPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::FlameUp::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::SpeedUp::SpeedUp(bool __ice_destructible, bool __ice_walkable, ::Ice::Int __ice_bomb, bool __ice_kick, ::Ice::Int __ice_power, ::Ice::Int __ice_speed) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus(__ice_destructible, __ice_walkable, __ice_bomb, __ice_kick, __ice_power, __ice_speed)
#else
    ::Bomberloutre::Bonus(__ice_destructible, __ice_walkable, __ice_bomb, __ice_kick, __ice_power, __ice_speed)
#endif

{
}

::Ice::ObjectPtr
Bomberloutre::SpeedUp::ice_clone() const
{
    ::Bomberloutre::SpeedUpPtr __p = new ::Bomberloutre::SpeedUp(*this);
    return __p;
}

static const ::std::string __Bomberloutre__SpeedUp_ids[4] =
{
    "::Bomberloutre::Bonus",
    "::Bomberloutre::MapItem",
    "::Bomberloutre::SpeedUp",
    "::Ice::Object"
};

bool
Bomberloutre::SpeedUp::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__SpeedUp_ids, __Bomberloutre__SpeedUp_ids + 4, _s);
}

::std::vector< ::std::string>
Bomberloutre::SpeedUp::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__SpeedUp_ids[0], &__Bomberloutre__SpeedUp_ids[4]);
}

const ::std::string&
Bomberloutre::SpeedUp::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__SpeedUp_ids[2];
}

const ::std::string&
Bomberloutre::SpeedUp::ice_staticId()
{
    return __Bomberloutre__SpeedUp_ids[2];
}

void
Bomberloutre::SpeedUp::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus::__write(__os);
#else
    ::Bomberloutre::Bonus::__write(__os);
#endif
}

void
Bomberloutre::SpeedUp::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus::__read(__is, true);
#else
    ::Bomberloutre::Bonus::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::SpeedUp::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::SpeedUp was not generated with stream support";
    throw ex;
}

void
Bomberloutre::SpeedUp::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::SpeedUp was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__SpeedUp : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::SpeedUp::ice_staticId());
        return new ::Bomberloutre::SpeedUp;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__SpeedUp_Ptr = new __F__Bomberloutre__SpeedUp;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::SpeedUp::ice_factory()
{
    return __F__Bomberloutre__SpeedUp_Ptr;
}

class __F__Bomberloutre__SpeedUp__Init
{
public:

    __F__Bomberloutre__SpeedUp__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::SpeedUp::ice_staticId(), ::Bomberloutre::SpeedUp::ice_factory());
    }

    ~__F__Bomberloutre__SpeedUp__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::SpeedUp::ice_staticId());
    }
};

static __F__Bomberloutre__SpeedUp__Init __F__Bomberloutre__SpeedUp__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__SpeedUp__initializer() {} }
#endif

void 
Bomberloutre::__patch__SpeedUpPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::SpeedUpPtr* p = static_cast< ::Bomberloutre::SpeedUpPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::SpeedUpPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::SpeedUp::ice_staticId(), v->ice_id());
    }
}

Bomberloutre::BombUp::BombUp(bool __ice_destructible, bool __ice_walkable, ::Ice::Int __ice_bomb, bool __ice_kick, ::Ice::Int __ice_power, ::Ice::Int __ice_speed) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus(__ice_destructible, __ice_walkable, __ice_bomb, __ice_kick, __ice_power, __ice_speed)
#else
    ::Bomberloutre::Bonus(__ice_destructible, __ice_walkable, __ice_bomb, __ice_kick, __ice_power, __ice_speed)
#endif

{
}

::Ice::ObjectPtr
Bomberloutre::BombUp::ice_clone() const
{
    ::Bomberloutre::BombUpPtr __p = new ::Bomberloutre::BombUp(*this);
    return __p;
}

static const ::std::string __Bomberloutre__BombUp_ids[4] =
{
    "::Bomberloutre::BombUp",
    "::Bomberloutre::Bonus",
    "::Bomberloutre::MapItem",
    "::Ice::Object"
};

bool
Bomberloutre::BombUp::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__BombUp_ids, __Bomberloutre__BombUp_ids + 4, _s);
}

::std::vector< ::std::string>
Bomberloutre::BombUp::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__BombUp_ids[0], &__Bomberloutre__BombUp_ids[4]);
}

const ::std::string&
Bomberloutre::BombUp::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__BombUp_ids[0];
}

const ::std::string&
Bomberloutre::BombUp::ice_staticId()
{
    return __Bomberloutre__BombUp_ids[0];
}

void
Bomberloutre::BombUp::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus::__write(__os);
#else
    ::Bomberloutre::Bonus::__write(__os);
#endif
}

void
Bomberloutre::BombUp::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Bonus::__read(__is, true);
#else
    ::Bomberloutre::Bonus::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::BombUp::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::BombUp was not generated with stream support";
    throw ex;
}

void
Bomberloutre::BombUp::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::BombUp was not generated with stream support";
    throw ex;
}
#endif

class __F__Bomberloutre__BombUp : public ::Ice::ObjectFactory
{
public:

    virtual ::Ice::ObjectPtr
    create(const ::std::string& type)
    {
        assert(type == ::Bomberloutre::BombUp::ice_staticId());
        return new ::Bomberloutre::BombUp;
    }

    virtual void
    destroy()
    {
    }
};

static ::Ice::ObjectFactoryPtr __F__Bomberloutre__BombUp_Ptr = new __F__Bomberloutre__BombUp;

const ::Ice::ObjectFactoryPtr&
Bomberloutre::BombUp::ice_factory()
{
    return __F__Bomberloutre__BombUp_Ptr;
}

class __F__Bomberloutre__BombUp__Init
{
public:

    __F__Bomberloutre__BombUp__Init()
    {
        ::IceInternal::factoryTable->addObjectFactory(::Bomberloutre::BombUp::ice_staticId(), ::Bomberloutre::BombUp::ice_factory());
    }

    ~__F__Bomberloutre__BombUp__Init()
    {
        ::IceInternal::factoryTable->removeObjectFactory(::Bomberloutre::BombUp::ice_staticId());
    }
};

static __F__Bomberloutre__BombUp__Init __F__Bomberloutre__BombUp__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__BombUp__initializer() {} }
#endif

void 
Bomberloutre::__patch__BombUpPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::BombUpPtr* p = static_cast< ::Bomberloutre::BombUpPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::BombUpPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::BombUp::ice_staticId(), v->ice_id());
    }
}
