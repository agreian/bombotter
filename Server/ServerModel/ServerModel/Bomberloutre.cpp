// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Bomberloutre.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Bomberloutre.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __Bomberloutre__GameInterface__getName_name = "getName";

static const ::std::string __Bomberloutre__GameInterface__getState_name = "getState";

static const ::std::string __Bomberloutre__GameInterface__getRoundCount_name = "getRoundCount";

static const ::std::string __Bomberloutre__GameInterface__setName_name = "setName";

static const ::std::string __Bomberloutre__GameInterface__setState_name = "setState";

static const ::std::string __Bomberloutre__GameInterface__setRoundCount_name = "setRoundCount";

static const ::std::string __Bomberloutre__GameInterface__kickPlayer_name = "kickPlayer";

static const ::std::string __Bomberloutre__GameInterface__invitePlayer_name = "invitePlayer";

static const ::std::string __Bomberloutre__GameInterface__addBot_name = "addBot";

static const ::std::string __Bomberloutre__GameInterface__removeBot_name = "removeBot";

static const ::std::string __Bomberloutre__GameInterface__createMap_name = "createMap";

static const ::std::string __Bomberloutre__GameInterface__startMap_name = "startMap";

static const ::std::string __Bomberloutre__GameInterface__endMap_name = "endMap";

static const ::std::string __Bomberloutre__GameInterface__removeGame_name = "removeGame";

static const ::std::string __Bomberloutre__GameWaitRoom__newUserInRoom_name = "newUserInRoom";

static const ::std::string __Bomberloutre__GameWaitRoom__userLeftRoom_name = "userLeftRoom";

static const ::std::string __Bomberloutre__GameWaitRoom__allUsersReady_name = "allUsersReady";

static const ::std::string __Bomberloutre__GameWaitRoom__userReady_name = "userReady";

static const ::std::string __Bomberloutre__GameWaitRoom__gameStart_name = "gameStart";

static const ::std::string __Bomberloutre__GameWaitRoom__gameEnd_name = "gameEnd";

static const ::std::string __Bomberloutre__MapInterface__getId_name = "getId";

static const ::std::string __Bomberloutre__MapInterface__getWidth_name = "getWidth";

static const ::std::string __Bomberloutre__MapInterface__getHeight_name = "getHeight";

static const ::std::string __Bomberloutre__MapInterface__move_name = "move";

static const ::std::string __Bomberloutre__MapInterface__kickBomb_name = "kickBomb";

static const ::std::string __Bomberloutre__MapInterface__dropBomb_name = "dropBomb";

static const ::std::string __Bomberloutre__MapObserver__refreshMapItems_name = "refreshMapItems";

static const ::std::string __Bomberloutre__MapObserver__refreshPlayers_name = "refreshPlayers";

static const ::std::string __Bomberloutre__MapObserver__bombHasBeenPlanted_name = "bombHasBeenPlanted";

static const ::std::string __Bomberloutre__MapObserver__bombExploded_name = "bombExploded";

static const ::std::string __Bomberloutre__MapObserver__bonusesDropped_name = "bonusesDropped";

static const ::std::string __Bomberloutre__ServerInterface__connect_name = "connect";

static const ::std::string __Bomberloutre__ServerInterface__createUser_name = "createUser";

static const ::std::string __Bomberloutre__ServerInterface__deleteUser_name = "deleteUser";

static const ::std::string __Bomberloutre__ServerInterface__addGame_name = "addGame";

static const ::std::string __Bomberloutre__ServerInterface__joinGame_name = "joinGame";

static const ::std::string __Bomberloutre__ServerInterface__getGameList_name = "getGameList";

static const ::std::string __Bomberloutre__ServerInterface__getUserList_name = "getUserList";

::Ice::Object* IceInternal::upCast(::Bomberloutre::GameInterface* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::GameInterface* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::GameWaitRoom* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::GameWaitRoom* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::MapInterface* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::MapInterface* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::MapObserver* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::MapObserver* p) { return p; }

::Ice::Object* IceInternal::upCast(::Bomberloutre::ServerInterface* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::Bomberloutre::ServerInterface* p) { return p; }

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::GameInterfacePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::GameInterface;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::GameWaitRoomPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::GameWaitRoom;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::MapInterfacePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::MapInterface;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::MapObserverPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::MapObserver;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::__read(::IceInternal::BasicStream* __is, ::Bomberloutre::ServerInterfacePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Bomberloutre::ServerInterface;
        v->__copyFrom(proxy);
    }
}

void
Bomberloutre::UserData::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(gameTag);
    __os->write(gameCount);
    __os->write(winCount);
    __os->write(drawCount);
    __os->write(killCount);
    __os->write(deathCount);
    __os->write(suicideCount);
}

void
Bomberloutre::UserData::__read(::IceInternal::BasicStream* __is)
{
    __is->read(gameTag);
    __is->read(gameCount);
    __is->read(winCount);
    __is->read(drawCount);
    __is->read(killCount);
    __is->read(deathCount);
    __is->read(suicideCount);
}

void
Bomberloutre::__writeUserDataList(::IceInternal::BasicStream* __os, const ::Bomberloutre::UserData* begin, const ::Bomberloutre::UserData* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
Bomberloutre::__readUserDataList(::IceInternal::BasicStream* __is, ::Bomberloutre::UserDataList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(25, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
Bomberloutre::GameData::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(name);
    __os->write(roundCount);
    __os->write(state);
    __os->write(playerCount);
}

void
Bomberloutre::GameData::__read(::IceInternal::BasicStream* __is)
{
    __is->read(name);
    __is->read(roundCount);
    __is->read(state);
    __is->read(playerCount);
}

void
Bomberloutre::__writeGameDataList(::IceInternal::BasicStream* __os, const ::Bomberloutre::GameData* begin, const ::Bomberloutre::GameData* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
Bomberloutre::__readGameDataList(::IceInternal::BasicStream* __is, ::Bomberloutre::GameDataList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(13, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
Bomberloutre::Player::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(posX);
    __os->write(posY);
    __os->write(width);
    __os->write(height);
    __os->write(killCount);
    __os->write(deathCount);
    __os->write(suicideCount);
    related.__write(__os);
}

void
Bomberloutre::Player::__read(::IceInternal::BasicStream* __is)
{
    __is->read(posX);
    __is->read(posY);
    __is->read(width);
    __is->read(height);
    __is->read(killCount);
    __is->read(deathCount);
    __is->read(suicideCount);
    related.__read(__is);
}

void
Bomberloutre::__writePlayerList(::IceInternal::BasicStream* __os, const ::Bomberloutre::Player* begin, const ::Bomberloutre::Player* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
Bomberloutre::__readPlayerList(::IceInternal::BasicStream* __is, ::Bomberloutre::PlayerList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(53, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
Bomberloutre::Point::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(x);
    __os->write(y);
}

void
Bomberloutre::Point::__read(::IceInternal::BasicStream* __is)
{
    __is->read(x);
    __is->read(y);
}

void
Bomberloutre::Map::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mi.get())));
    if(items.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::Bomberloutre::__writeMapItems(__os, &items[0], &items[0] + items.size());
    }
    if(players.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::Bomberloutre::__writePlayerList(__os, &players[0], &players[0] + players.size());
    }
}

void
Bomberloutre::Map::__read(::IceInternal::BasicStream* __is)
{
    ::Bomberloutre::__read(__is, mi);
    ::Bomberloutre::__readMapItems(__is, items);
    ::Bomberloutre::__readPlayerList(__is, players);
}

Bomberloutre::UserException::UserException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(),
#else
    ::Ice::UserException(),
#endif
    reason(__ice_reason)
{
}

Bomberloutre::UserException::~UserException() throw()
{
}

static const char* __Bomberloutre__UserException_name = "Bomberloutre::UserException";

::std::string
Bomberloutre::UserException::ice_name() const
{
    return __Bomberloutre__UserException_name;
}

::Ice::Exception*
Bomberloutre::UserException::ice_clone() const
{
    return new UserException(*this);
}

void
Bomberloutre::UserException::ice_throw() const
{
    throw *this;
}

void
Bomberloutre::UserException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::Bomberloutre::UserException"), false);
    __os->startWriteSlice();
    __os->write(reason);
    __os->endWriteSlice();
}

void
Bomberloutre::UserException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->read(reason);
    __is->endReadSlice();
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::UserException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Bomberloutre::UserException was not generated with stream support";
    throw ex;
}

void
Bomberloutre::UserException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Bomberloutre::UserException was not generated with stream support";
    throw ex;
}
#endif

struct __F__Bomberloutre__UserException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::Bomberloutre::UserException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__Bomberloutre__UserException__Ptr = new __F__Bomberloutre__UserException;

const ::IceInternal::UserExceptionFactoryPtr&
Bomberloutre::UserException::ice_factory()
{
    return __F__Bomberloutre__UserException__Ptr;
}

class __F__Bomberloutre__UserException__Init
{
public:

    __F__Bomberloutre__UserException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Bomberloutre::UserException", ::Bomberloutre::UserException::ice_factory());
    }

    ~__F__Bomberloutre__UserException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Bomberloutre::UserException");
    }
};

static __F__Bomberloutre__UserException__Init __F__Bomberloutre__UserException__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__UserException__initializer() {} }
#endif

Bomberloutre::BadLoginException::BadLoginException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(__ice_reason)
#else
    ::Bomberloutre::UserException(__ice_reason)
#endif
{
}

Bomberloutre::BadLoginException::~BadLoginException() throw()
{
}

static const char* __Bomberloutre__BadLoginException_name = "Bomberloutre::BadLoginException";

::std::string
Bomberloutre::BadLoginException::ice_name() const
{
    return __Bomberloutre__BadLoginException_name;
}

::Ice::Exception*
Bomberloutre::BadLoginException::ice_clone() const
{
    return new BadLoginException(*this);
}

void
Bomberloutre::BadLoginException::ice_throw() const
{
    throw *this;
}

void
Bomberloutre::BadLoginException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::Bomberloutre::BadLoginException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__write(__os);
#else
    ::Bomberloutre::UserException::__write(__os);
#endif
}

void
Bomberloutre::BadLoginException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__read(__is, true);
#else
    ::Bomberloutre::UserException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::BadLoginException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Bomberloutre::BadLoginException was not generated with stream support";
    throw ex;
}

void
Bomberloutre::BadLoginException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Bomberloutre::BadLoginException was not generated with stream support";
    throw ex;
}
#endif

struct __F__Bomberloutre__BadLoginException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::Bomberloutre::BadLoginException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__Bomberloutre__BadLoginException__Ptr = new __F__Bomberloutre__BadLoginException;

const ::IceInternal::UserExceptionFactoryPtr&
Bomberloutre::BadLoginException::ice_factory()
{
    return __F__Bomberloutre__BadLoginException__Ptr;
}

class __F__Bomberloutre__BadLoginException__Init
{
public:

    __F__Bomberloutre__BadLoginException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Bomberloutre::BadLoginException", ::Bomberloutre::BadLoginException::ice_factory());
    }

    ~__F__Bomberloutre__BadLoginException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Bomberloutre::BadLoginException");
    }
};

static __F__Bomberloutre__BadLoginException__Init __F__Bomberloutre__BadLoginException__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__BadLoginException__initializer() {} }
#endif

Bomberloutre::BadPasswordException::BadPasswordException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(__ice_reason)
#else
    ::Bomberloutre::UserException(__ice_reason)
#endif
{
}

Bomberloutre::BadPasswordException::~BadPasswordException() throw()
{
}

static const char* __Bomberloutre__BadPasswordException_name = "Bomberloutre::BadPasswordException";

::std::string
Bomberloutre::BadPasswordException::ice_name() const
{
    return __Bomberloutre__BadPasswordException_name;
}

::Ice::Exception*
Bomberloutre::BadPasswordException::ice_clone() const
{
    return new BadPasswordException(*this);
}

void
Bomberloutre::BadPasswordException::ice_throw() const
{
    throw *this;
}

void
Bomberloutre::BadPasswordException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::Bomberloutre::BadPasswordException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__write(__os);
#else
    ::Bomberloutre::UserException::__write(__os);
#endif
}

void
Bomberloutre::BadPasswordException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__read(__is, true);
#else
    ::Bomberloutre::UserException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::BadPasswordException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Bomberloutre::BadPasswordException was not generated with stream support";
    throw ex;
}

void
Bomberloutre::BadPasswordException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Bomberloutre::BadPasswordException was not generated with stream support";
    throw ex;
}
#endif

struct __F__Bomberloutre__BadPasswordException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::Bomberloutre::BadPasswordException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__Bomberloutre__BadPasswordException__Ptr = new __F__Bomberloutre__BadPasswordException;

const ::IceInternal::UserExceptionFactoryPtr&
Bomberloutre::BadPasswordException::ice_factory()
{
    return __F__Bomberloutre__BadPasswordException__Ptr;
}

class __F__Bomberloutre__BadPasswordException__Init
{
public:

    __F__Bomberloutre__BadPasswordException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Bomberloutre::BadPasswordException", ::Bomberloutre::BadPasswordException::ice_factory());
    }

    ~__F__Bomberloutre__BadPasswordException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Bomberloutre::BadPasswordException");
    }
};

static __F__Bomberloutre__BadPasswordException__Init __F__Bomberloutre__BadPasswordException__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__BadPasswordException__initializer() {} }
#endif

Bomberloutre::UserAlreadyExistsException::UserAlreadyExistsException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(__ice_reason)
#else
    ::Bomberloutre::UserException(__ice_reason)
#endif
{
}

Bomberloutre::UserAlreadyExistsException::~UserAlreadyExistsException() throw()
{
}

static const char* __Bomberloutre__UserAlreadyExistsException_name = "Bomberloutre::UserAlreadyExistsException";

::std::string
Bomberloutre::UserAlreadyExistsException::ice_name() const
{
    return __Bomberloutre__UserAlreadyExistsException_name;
}

::Ice::Exception*
Bomberloutre::UserAlreadyExistsException::ice_clone() const
{
    return new UserAlreadyExistsException(*this);
}

void
Bomberloutre::UserAlreadyExistsException::ice_throw() const
{
    throw *this;
}

void
Bomberloutre::UserAlreadyExistsException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::Bomberloutre::UserAlreadyExistsException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__write(__os);
#else
    ::Bomberloutre::UserException::__write(__os);
#endif
}

void
Bomberloutre::UserAlreadyExistsException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__read(__is, true);
#else
    ::Bomberloutre::UserException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::UserAlreadyExistsException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Bomberloutre::UserAlreadyExistsException was not generated with stream support";
    throw ex;
}

void
Bomberloutre::UserAlreadyExistsException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception Bomberloutre::UserAlreadyExistsException was not generated with stream support";
    throw ex;
}
#endif

struct __F__Bomberloutre__UserAlreadyExistsException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::Bomberloutre::UserAlreadyExistsException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__Bomberloutre__UserAlreadyExistsException__Ptr = new __F__Bomberloutre__UserAlreadyExistsException;

const ::IceInternal::UserExceptionFactoryPtr&
Bomberloutre::UserAlreadyExistsException::ice_factory()
{
    return __F__Bomberloutre__UserAlreadyExistsException__Ptr;
}

class __F__Bomberloutre__UserAlreadyExistsException__Init
{
public:

    __F__Bomberloutre__UserAlreadyExistsException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Bomberloutre::UserAlreadyExistsException", ::Bomberloutre::UserAlreadyExistsException::ice_factory());
    }

    ~__F__Bomberloutre__UserAlreadyExistsException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Bomberloutre::UserAlreadyExistsException");
    }
};

static __F__Bomberloutre__UserAlreadyExistsException__Init __F__Bomberloutre__UserAlreadyExistsException__i;

#ifdef __APPLE__
extern "C" { void __F__Bomberloutre__UserAlreadyExistsException__initializer() {} }
#endif

::std::string
IceProxy::Bomberloutre::GameInterface::getName(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__GameInterface__getName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            return __del->getName(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_getName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__GameInterface__getName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__getName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__getName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::Bomberloutre::GameInterface::end_getName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__GameInterface__getName_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::Bomberloutre::GameInterface::getState(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__GameInterface__getState_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            return __del->getState(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_getState(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__GameInterface__getState_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__getState_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__getState_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Bomberloutre::GameInterface::end_getState(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__GameInterface__getState_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::Bomberloutre::GameInterface::getRoundCount(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__GameInterface__getRoundCount_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            return __del->getRoundCount(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_getRoundCount(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__GameInterface__getRoundCount_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__getRoundCount_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__getRoundCount_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Bomberloutre::GameInterface::end_getRoundCount(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__GameInterface__getRoundCount_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::Bomberloutre::GameInterface::setName(const ::std::string& newname, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->setName(newname, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_setName(const ::std::string& newname, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__setName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__setName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(newname);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_setName(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__setName_name);
}

void
IceProxy::Bomberloutre::GameInterface::setState(::Ice::Int newstate, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->setState(newstate, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_setState(::Ice::Int newstate, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__setState_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__setState_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(newstate);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_setState(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__setState_name);
}

void
IceProxy::Bomberloutre::GameInterface::setRoundCount(::Ice::Int newcount, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->setRoundCount(newcount, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_setRoundCount(::Ice::Int newcount, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__setRoundCount_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__setRoundCount_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(newcount);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_setRoundCount(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__setRoundCount_name);
}

void
IceProxy::Bomberloutre::GameInterface::kickPlayer(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->kickPlayer(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_kickPlayer(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__kickPlayer_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__kickPlayer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_kickPlayer(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__kickPlayer_name);
}

void
IceProxy::Bomberloutre::GameInterface::invitePlayer(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->invitePlayer(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_invitePlayer(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__invitePlayer_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__invitePlayer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_invitePlayer(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__invitePlayer_name);
}

void
IceProxy::Bomberloutre::GameInterface::addBot(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->addBot(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_addBot(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__addBot_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__addBot_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_addBot(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__addBot_name);
}

void
IceProxy::Bomberloutre::GameInterface::removeBot(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->removeBot(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_removeBot(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__removeBot_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__removeBot_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_removeBot(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__removeBot_name);
}

bool
IceProxy::Bomberloutre::GameInterface::createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__GameInterface__createMap_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            return __del->createMap(mode, mapSkin, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__GameInterface__createMap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__createMap_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__createMap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(mode);
        __os->write(mapSkin);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Bomberloutre::GameInterface::end_createMap(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__GameInterface__createMap_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::Bomberloutre::GameInterface::startMap(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->startMap(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_startMap(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__startMap_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__startMap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_startMap(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__startMap_name);
}

void
IceProxy::Bomberloutre::GameInterface::endMap(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            __del->endMap(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_endMap(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__endMap_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__endMap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameInterface::end_endMap(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameInterface__endMap_name);
}

bool
IceProxy::Bomberloutre::GameInterface::removeGame(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__GameInterface__removeGame_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameInterface*>(__delBase.get());
            return __del->removeGame(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameInterface::begin_removeGame(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__GameInterface__removeGame_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameInterface__removeGame_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameInterface__removeGame_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Bomberloutre::GameInterface::end_removeGame(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__GameInterface__removeGame_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::Bomberloutre::GameInterface::ice_staticId()
{
    return ::Bomberloutre::GameInterface::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::GameInterface::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::GameInterface);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::GameInterface::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::GameInterface);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::GameInterface::__newInstance() const
{
    return new GameInterface;
}

void
IceProxy::Bomberloutre::GameWaitRoom::newUserInRoom(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameWaitRoom*>(__delBase.get());
            __del->newUserInRoom(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameWaitRoom::begin_newUserInRoom(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameWaitRoom__newUserInRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameWaitRoom__newUserInRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameWaitRoom::end_newUserInRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameWaitRoom__newUserInRoom_name);
}

void
IceProxy::Bomberloutre::GameWaitRoom::userLeftRoom(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameWaitRoom*>(__delBase.get());
            __del->userLeftRoom(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameWaitRoom::begin_userLeftRoom(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameWaitRoom__userLeftRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameWaitRoom__userLeftRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameWaitRoom::end_userLeftRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameWaitRoom__userLeftRoom_name);
}

void
IceProxy::Bomberloutre::GameWaitRoom::allUsersReady(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameWaitRoom*>(__delBase.get());
            __del->allUsersReady(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameWaitRoom::begin_allUsersReady(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameWaitRoom__allUsersReady_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameWaitRoom__allUsersReady_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameWaitRoom::end_allUsersReady(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameWaitRoom__allUsersReady_name);
}

void
IceProxy::Bomberloutre::GameWaitRoom::userReady(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameWaitRoom*>(__delBase.get());
            __del->userReady(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameWaitRoom::begin_userReady(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameWaitRoom__userReady_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameWaitRoom__userReady_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameWaitRoom::end_userReady(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameWaitRoom__userReady_name);
}

void
IceProxy::Bomberloutre::GameWaitRoom::gameStart(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameWaitRoom*>(__delBase.get());
            __del->gameStart(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameWaitRoom::begin_gameStart(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameWaitRoom__gameStart_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameWaitRoom__gameStart_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameWaitRoom::end_gameStart(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameWaitRoom__gameStart_name);
}

void
IceProxy::Bomberloutre::GameWaitRoom::gameEnd(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::Bomberloutre::GameWaitRoom*>(__delBase.get());
            __del->gameEnd(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::GameWaitRoom::begin_gameEnd(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__GameWaitRoom__gameEnd_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__GameWaitRoom__gameEnd_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::GameWaitRoom::end_gameEnd(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__GameWaitRoom__gameEnd_name);
}

const ::std::string&
IceProxy::Bomberloutre::GameWaitRoom::ice_staticId()
{
    return ::Bomberloutre::GameWaitRoom::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::GameWaitRoom::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::GameWaitRoom);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::GameWaitRoom::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::GameWaitRoom);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::GameWaitRoom::__newInstance() const
{
    return new GameWaitRoom;
}

::std::string
IceProxy::Bomberloutre::MapInterface::getId(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__MapInterface__getId_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapInterface*>(__delBase.get());
            return __del->getId(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapInterface::begin_getId(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__MapInterface__getId_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapInterface__getId_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapInterface__getId_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::Bomberloutre::MapInterface::end_getId(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__MapInterface__getId_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::Bomberloutre::MapInterface::getWidth(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__MapInterface__getWidth_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapInterface*>(__delBase.get());
            return __del->getWidth(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapInterface::begin_getWidth(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__MapInterface__getWidth_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapInterface__getWidth_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapInterface__getWidth_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Bomberloutre::MapInterface::end_getWidth(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__MapInterface__getWidth_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::Bomberloutre::MapInterface::getHeight(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__MapInterface__getHeight_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapInterface*>(__delBase.get());
            return __del->getHeight(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapInterface::begin_getHeight(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__MapInterface__getHeight_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapInterface__getHeight_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapInterface__getHeight_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::Bomberloutre::MapInterface::end_getHeight(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__MapInterface__getHeight_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

bool
IceProxy::Bomberloutre::MapInterface::move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__MapInterface__move_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapInterface*>(__delBase.get());
            return __del->move(p, pt, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapInterface::begin_move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__MapInterface__move_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapInterface__move_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapInterface__move_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        pt.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Bomberloutre::MapInterface::end_move(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__MapInterface__move_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::Bomberloutre::MapInterface::kickBomb(const ::Bomberloutre::Player& p, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapInterface*>(__delBase.get());
            __del->kickBomb(p, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapInterface::begin_kickBomb(const ::Bomberloutre::Player& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapInterface__kickBomb_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapInterface__kickBomb_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::MapInterface::end_kickBomb(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__MapInterface__kickBomb_name);
}

void
IceProxy::Bomberloutre::MapInterface::dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapInterface*>(__delBase.get());
            __del->dropBomb(p, b, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapInterface::begin_dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapInterface__dropBomb_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapInterface__dropBomb_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(b.get())));
        __os->writePendingObjects();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::MapInterface::end_dropBomb(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__MapInterface__dropBomb_name);
}

const ::std::string&
IceProxy::Bomberloutre::MapInterface::ice_staticId()
{
    return ::Bomberloutre::MapInterface::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::MapInterface::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::MapInterface);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::MapInterface::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::MapInterface);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::MapInterface::__newInstance() const
{
    return new MapInterface;
}

void
IceProxy::Bomberloutre::MapObserver::refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapObserver* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapObserver*>(__delBase.get());
            __del->refreshMapItems(mi, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapObserver::begin_refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapObserver__refreshMapItems_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapObserver__refreshMapItems_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(mi.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::Bomberloutre::__writeMapItems(__os, &mi[0], &mi[0] + mi.size());
        }
        __os->writePendingObjects();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::MapObserver::end_refreshMapItems(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__MapObserver__refreshMapItems_name);
}

void
IceProxy::Bomberloutre::MapObserver::refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapObserver* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapObserver*>(__delBase.get());
            __del->refreshPlayers(p, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapObserver::begin_refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapObserver__refreshPlayers_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapObserver__refreshPlayers_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(p.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::Bomberloutre::__writePlayerList(__os, &p[0], &p[0] + p.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::MapObserver::end_refreshPlayers(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__MapObserver__refreshPlayers_name);
}

void
IceProxy::Bomberloutre::MapObserver::bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapObserver* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapObserver*>(__delBase.get());
            __del->bombHasBeenPlanted(b, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapObserver::begin_bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapObserver__bombHasBeenPlanted_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapObserver__bombHasBeenPlanted_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(b.get())));
        __os->writePendingObjects();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::MapObserver::end_bombHasBeenPlanted(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__MapObserver__bombHasBeenPlanted_name);
}

void
IceProxy::Bomberloutre::MapObserver::bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapObserver* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapObserver*>(__delBase.get());
            __del->bombExploded(b, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapObserver::begin_bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapObserver__bombExploded_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapObserver__bombExploded_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(b.get())));
        __os->writePendingObjects();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::MapObserver::end_bombExploded(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__MapObserver__bombExploded_name);
}

void
IceProxy::Bomberloutre::MapObserver::bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::MapObserver* __del = dynamic_cast< ::IceDelegate::Bomberloutre::MapObserver*>(__delBase.get());
            __del->bonusesDropped(b, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::MapObserver::begin_bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__MapObserver__bonusesDropped_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__MapObserver__bonusesDropped_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(b.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::Bomberloutre::__writeBonuses(__os, &b[0], &b[0] + b.size());
        }
        __os->writePendingObjects();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Bomberloutre::MapObserver::end_bonusesDropped(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Bomberloutre__MapObserver__bonusesDropped_name);
}

const ::std::string&
IceProxy::Bomberloutre::MapObserver::ice_staticId()
{
    return ::Bomberloutre::MapObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::MapObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::MapObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::MapObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::MapObserver);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::MapObserver::__newInstance() const
{
    return new MapObserver;
}

::Bomberloutre::UserData
IceProxy::Bomberloutre::ServerInterface::connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__ServerInterface__connect_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::ServerInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::ServerInterface*>(__delBase.get());
            return __del->connect(login, password, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::ServerInterface::begin_connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__ServerInterface__connect_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__ServerInterface__connect_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__ServerInterface__connect_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(login);
        __os->write(password);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Bomberloutre::UserData
IceProxy::Bomberloutre::ServerInterface::end_connect(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__ServerInterface__connect_name);
    ::Bomberloutre::UserData __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Bomberloutre::BadLoginException&)
        {
            throw;
        }
        catch(const ::Bomberloutre::BadPasswordException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

::Bomberloutre::UserData
IceProxy::Bomberloutre::ServerInterface::createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__ServerInterface__createUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::ServerInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::ServerInterface*>(__delBase.get());
            return __del->createUser(login, password, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::ServerInterface::begin_createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__ServerInterface__createUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__ServerInterface__createUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__ServerInterface__createUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(login);
        __os->write(password);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Bomberloutre::UserData
IceProxy::Bomberloutre::ServerInterface::end_createUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__ServerInterface__createUser_name);
    ::Bomberloutre::UserData __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Bomberloutre::UserAlreadyExistsException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

bool
IceProxy::Bomberloutre::ServerInterface::deleteUser(const ::std::string& login, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__ServerInterface__deleteUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::ServerInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::ServerInterface*>(__delBase.get());
            return __del->deleteUser(login, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::ServerInterface::begin_deleteUser(const ::std::string& login, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__ServerInterface__deleteUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__ServerInterface__deleteUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__ServerInterface__deleteUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(login);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Bomberloutre::ServerInterface::end_deleteUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__ServerInterface__deleteUser_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Bomberloutre::GameInterfacePrx
IceProxy::Bomberloutre::ServerInterface::addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__ServerInterface__addGame_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::ServerInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::ServerInterface*>(__delBase.get());
            return __del->addGame(name, room, mo, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::ServerInterface::begin_addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__ServerInterface__addGame_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__ServerInterface__addGame_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__ServerInterface__addGame_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(name);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(room.get())));
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mo.get())));
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Bomberloutre::GameInterfacePrx
IceProxy::Bomberloutre::ServerInterface::end_addGame(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__ServerInterface__addGame_name);
    ::Bomberloutre::GameInterfacePrx __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::Bomberloutre::__read(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::Bomberloutre::Map
IceProxy::Bomberloutre::ServerInterface::joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__ServerInterface__joinGame_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::ServerInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::ServerInterface*>(__delBase.get());
            return __del->joinGame(name, room, mo, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::ServerInterface::begin_joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__ServerInterface__joinGame_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__ServerInterface__joinGame_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__ServerInterface__joinGame_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(name);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(room.get())));
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mo.get())));
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Bomberloutre::Map
IceProxy::Bomberloutre::ServerInterface::end_joinGame(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__ServerInterface__joinGame_name);
    ::Bomberloutre::Map __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->readPendingObjects();
    __is->endReadEncaps();
    return __ret;
}

::Bomberloutre::GameDataList
IceProxy::Bomberloutre::ServerInterface::getGameList(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__ServerInterface__getGameList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::ServerInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::ServerInterface*>(__delBase.get());
            return __del->getGameList(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::ServerInterface::begin_getGameList(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__ServerInterface__getGameList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__ServerInterface__getGameList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__ServerInterface__getGameList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Bomberloutre::GameDataList
IceProxy::Bomberloutre::ServerInterface::end_getGameList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__ServerInterface__getGameList_name);
    ::Bomberloutre::GameDataList __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::Bomberloutre::__readGameDataList(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::Bomberloutre::UserDataList
IceProxy::Bomberloutre::ServerInterface::getUserList(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Bomberloutre__ServerInterface__getUserList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Bomberloutre::ServerInterface* __del = dynamic_cast< ::IceDelegate::Bomberloutre::ServerInterface*>(__delBase.get());
            return __del->getUserList(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Bomberloutre::ServerInterface::begin_getUserList(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Bomberloutre__ServerInterface__getUserList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Bomberloutre__ServerInterface__getUserList_name, __del, __cookie);
    try
    {
        __result->__prepare(__Bomberloutre__ServerInterface__getUserList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Bomberloutre::UserDataList
IceProxy::Bomberloutre::ServerInterface::end_getUserList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Bomberloutre__ServerInterface__getUserList_name);
    ::Bomberloutre::UserDataList __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::Bomberloutre::__readUserDataList(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::Bomberloutre::ServerInterface::ice_staticId()
{
    return ::Bomberloutre::ServerInterface::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Bomberloutre::ServerInterface::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Bomberloutre::ServerInterface);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Bomberloutre::ServerInterface::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Bomberloutre::ServerInterface);
}

::IceProxy::Ice::Object*
IceProxy::Bomberloutre::ServerInterface::__newInstance() const
{
    return new ServerInterface;
}

::std::string
IceDelegateM::Bomberloutre::GameInterface::getName(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__getName_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Bomberloutre::GameInterface::getState(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__getState_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Bomberloutre::GameInterface::getRoundCount(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__getRoundCount_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::setName(const ::std::string& newname, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__setName_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(newname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::setState(::Ice::Int newstate, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__setState_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(newstate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::setRoundCount(::Ice::Int newcount, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__setRoundCount_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(newcount);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::kickPlayer(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__kickPlayer_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::invitePlayer(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__invitePlayer_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::addBot(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__addBot_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::removeBot(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__removeBot_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::Bomberloutre::GameInterface::createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__createMap_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(mode);
        __os->write(mapSkin);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::startMap(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__startMap_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameInterface::endMap(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__endMap_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::Bomberloutre::GameInterface::removeGame(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameInterface__removeGame_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Bomberloutre::GameWaitRoom::newUserInRoom(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameWaitRoom__newUserInRoom_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameWaitRoom::userLeftRoom(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameWaitRoom__userLeftRoom_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameWaitRoom::allUsersReady(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameWaitRoom__allUsersReady_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameWaitRoom::userReady(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameWaitRoom__userReady_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameWaitRoom::gameStart(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameWaitRoom__gameStart_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::GameWaitRoom::gameEnd(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__GameWaitRoom__gameEnd_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::std::string
IceDelegateM::Bomberloutre::MapInterface::getId(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapInterface__getId_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Bomberloutre::MapInterface::getWidth(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapInterface__getWidth_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::Bomberloutre::MapInterface::getHeight(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapInterface__getHeight_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::Bomberloutre::MapInterface::move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapInterface__move_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
        pt.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Bomberloutre::MapInterface::kickBomb(const ::Bomberloutre::Player& p, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapInterface__kickBomb_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::MapInterface::dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapInterface__dropBomb_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(b.get())));
        __os->writePendingObjects();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::MapObserver::refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapObserver__refreshMapItems_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(mi.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::Bomberloutre::__writeMapItems(__os, &mi[0], &mi[0] + mi.size());
        }
        __os->writePendingObjects();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::MapObserver::refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapObserver__refreshPlayers_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(p.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::Bomberloutre::__writePlayerList(__os, &p[0], &p[0] + p.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::MapObserver::bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapObserver__bombHasBeenPlanted_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(b.get())));
        __os->writePendingObjects();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::MapObserver::bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapObserver__bombExploded_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(::Ice::ObjectPtr(::IceInternal::upCast(b.get())));
        __os->writePendingObjects();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Bomberloutre::MapObserver::bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__MapObserver__bonusesDropped_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(b.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::Bomberloutre::__writeBonuses(__os, &b[0], &b[0] + b.size());
        }
        __os->writePendingObjects();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Bomberloutre::UserData
IceDelegateM::Bomberloutre::ServerInterface::connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__ServerInterface__connect_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(login);
        __os->write(password);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Bomberloutre::UserData __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Bomberloutre::BadLoginException&)
            {
                throw;
            }
            catch(const ::Bomberloutre::BadPasswordException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Bomberloutre::UserData
IceDelegateM::Bomberloutre::ServerInterface::createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__ServerInterface__createUser_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(login);
        __os->write(password);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Bomberloutre::UserData __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Bomberloutre::UserAlreadyExistsException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::Bomberloutre::ServerInterface::deleteUser(const ::std::string& login, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__ServerInterface__deleteUser_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(login);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Bomberloutre::GameInterfacePrx
IceDelegateM::Bomberloutre::ServerInterface::addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__ServerInterface__addGame_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(name);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(room.get())));
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mo.get())));
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Bomberloutre::GameInterfacePrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::Bomberloutre::__read(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Bomberloutre::Map
IceDelegateM::Bomberloutre::ServerInterface::joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__ServerInterface__joinGame_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(name);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(room.get())));
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mo.get())));
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Bomberloutre::Map __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->readPendingObjects();
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Bomberloutre::GameDataList
IceDelegateM::Bomberloutre::ServerInterface::getGameList(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__ServerInterface__getGameList_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Bomberloutre::GameDataList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::Bomberloutre::__readGameDataList(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Bomberloutre::UserDataList
IceDelegateM::Bomberloutre::ServerInterface::getUserList(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Bomberloutre__ServerInterface__getUserList_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Bomberloutre::UserDataList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::Bomberloutre::__readUserDataList(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateD::Bomberloutre::GameInterface::getName(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getName(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__getName_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Bomberloutre::GameInterface::getState(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getState(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__getState_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Bomberloutre::GameInterface::getRoundCount(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getRoundCount(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__getRoundCount_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Bomberloutre::GameInterface::setName(const ::std::string& newname, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& newname, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_newname(newname)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setName(_m_newname, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_newname;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__setName_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(newname, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameInterface::setState(::Ice::Int newstate, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int newstate, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_newstate(newstate)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setState(_m_newstate, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_newstate;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__setState_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(newstate, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameInterface::setRoundCount(::Ice::Int newcount, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int newcount, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_newcount(newcount)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setRoundCount(_m_newcount, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_newcount;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__setRoundCount_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(newcount, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameInterface::kickPlayer(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->kickPlayer(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__kickPlayer_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameInterface::invitePlayer(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->invitePlayer(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__invitePlayer_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameInterface::addBot(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->addBot(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__addBot_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameInterface::removeBot(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->removeBot(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__removeBot_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::Bomberloutre::GameInterface::createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_mode(mode),
            _m_mapSkin(mapSkin)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->createMap(_m_mode, _m_mapSkin, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_mode;
        const ::std::string& _m_mapSkin;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__createMap_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, mode, mapSkin, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Bomberloutre::GameInterface::startMap(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->startMap(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__startMap_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameInterface::endMap(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->endMap(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__endMap_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::Bomberloutre::GameInterface::removeGame(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameInterface* servant = dynamic_cast< ::Bomberloutre::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->removeGame(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameInterface__removeGame_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Bomberloutre::GameWaitRoom::newUserInRoom(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameWaitRoom* servant = dynamic_cast< ::Bomberloutre::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->newUserInRoom(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameWaitRoom__newUserInRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameWaitRoom::userLeftRoom(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameWaitRoom* servant = dynamic_cast< ::Bomberloutre::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userLeftRoom(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameWaitRoom__userLeftRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameWaitRoom::allUsersReady(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameWaitRoom* servant = dynamic_cast< ::Bomberloutre::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->allUsersReady(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameWaitRoom__allUsersReady_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameWaitRoom::userReady(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameWaitRoom* servant = dynamic_cast< ::Bomberloutre::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userReady(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameWaitRoom__userReady_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameWaitRoom::gameStart(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameWaitRoom* servant = dynamic_cast< ::Bomberloutre::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->gameStart(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameWaitRoom__gameStart_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::GameWaitRoom::gameEnd(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::GameWaitRoom* servant = dynamic_cast< ::Bomberloutre::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->gameEnd(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__GameWaitRoom__gameEnd_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::Bomberloutre::MapInterface::getId(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapInterface* servant = dynamic_cast< ::Bomberloutre::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getId(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapInterface__getId_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Bomberloutre::MapInterface::getWidth(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapInterface* servant = dynamic_cast< ::Bomberloutre::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getWidth(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapInterface__getWidth_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::Bomberloutre::MapInterface::getHeight(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapInterface* servant = dynamic_cast< ::Bomberloutre::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getHeight(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapInterface__getHeight_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

bool
IceDelegateD::Bomberloutre::MapInterface::move(const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Bomberloutre::Player& p, const ::Bomberloutre::Point& pt, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_p(p),
            _m_pt(pt)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapInterface* servant = dynamic_cast< ::Bomberloutre::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->move(_m_p, _m_pt, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::Bomberloutre::Player& _m_p;
        const ::Bomberloutre::Point& _m_pt;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapInterface__move_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, p, pt, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Bomberloutre::MapInterface::kickBomb(const ::Bomberloutre::Player& p, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Bomberloutre::Player& p, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapInterface* servant = dynamic_cast< ::Bomberloutre::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->kickBomb(_m_p, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Bomberloutre::Player& _m_p;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapInterface__kickBomb_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::MapInterface::dropBomb(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Bomberloutre::Player& p, const ::Bomberloutre::BombPtr& b, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p),
            _m_b(b)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapInterface* servant = dynamic_cast< ::Bomberloutre::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->dropBomb(_m_p, _m_b, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Bomberloutre::Player& _m_p;
        const ::Bomberloutre::BombPtr& _m_b;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapInterface__dropBomb_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, b, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::MapObserver::refreshMapItems(const ::Bomberloutre::MapItems& mi, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Bomberloutre::MapItems& mi, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_mi(mi)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapObserver* servant = dynamic_cast< ::Bomberloutre::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->refreshMapItems(_m_mi, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Bomberloutre::MapItems& _m_mi;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapObserver__refreshMapItems_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(mi, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::MapObserver::refreshPlayers(const ::Bomberloutre::PlayerList& p, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Bomberloutre::PlayerList& p, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapObserver* servant = dynamic_cast< ::Bomberloutre::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->refreshPlayers(_m_p, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Bomberloutre::PlayerList& _m_p;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapObserver__refreshPlayers_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::MapObserver::bombHasBeenPlanted(const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Bomberloutre::BombPtr& b, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_b(b)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapObserver* servant = dynamic_cast< ::Bomberloutre::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->bombHasBeenPlanted(_m_b, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Bomberloutre::BombPtr& _m_b;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapObserver__bombHasBeenPlanted_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(b, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::MapObserver::bombExploded(const ::Bomberloutre::BombPtr& b, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Bomberloutre::BombPtr& b, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_b(b)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapObserver* servant = dynamic_cast< ::Bomberloutre::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->bombExploded(_m_b, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Bomberloutre::BombPtr& _m_b;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapObserver__bombExploded_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(b, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Bomberloutre::MapObserver::bonusesDropped(const ::Bomberloutre::Bonuses& b, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Bomberloutre::Bonuses& b, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_b(b)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::MapObserver* servant = dynamic_cast< ::Bomberloutre::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->bonusesDropped(_m_b, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Bomberloutre::Bonuses& _m_b;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__MapObserver__bonusesDropped_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(b, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Bomberloutre::UserData
IceDelegateD::Bomberloutre::ServerInterface::connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Bomberloutre::UserData& __result, const ::std::string& login, const ::std::string& password, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_login(login),
            _m_password(password)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::ServerInterface* servant = dynamic_cast< ::Bomberloutre::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->connect(_m_login, _m_password, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Bomberloutre::UserData& _result;
        const ::std::string& _m_login;
        const ::std::string& _m_password;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__ServerInterface__connect_name, ::Ice::Normal, __context);
    ::Bomberloutre::UserData __result;
    try
    {
        _DirectI __direct(__result, login, password, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Bomberloutre::BadLoginException&)
    {
        throw;
    }
    catch(const ::Bomberloutre::BadPasswordException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Bomberloutre::UserData
IceDelegateD::Bomberloutre::ServerInterface::createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Bomberloutre::UserData& __result, const ::std::string& login, const ::std::string& password, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_login(login),
            _m_password(password)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::ServerInterface* servant = dynamic_cast< ::Bomberloutre::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->createUser(_m_login, _m_password, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Bomberloutre::UserData& _result;
        const ::std::string& _m_login;
        const ::std::string& _m_password;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__ServerInterface__createUser_name, ::Ice::Normal, __context);
    ::Bomberloutre::UserData __result;
    try
    {
        _DirectI __direct(__result, login, password, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Bomberloutre::UserAlreadyExistsException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

bool
IceDelegateD::Bomberloutre::ServerInterface::deleteUser(const ::std::string& login, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& login, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_login(login)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::ServerInterface* servant = dynamic_cast< ::Bomberloutre::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->deleteUser(_m_login, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_login;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__ServerInterface__deleteUser_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, login, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Bomberloutre::GameInterfacePrx
IceDelegateD::Bomberloutre::ServerInterface::addGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Bomberloutre::GameInterfacePrx& __result, const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_name(name),
            _m_room(room),
            _m_mo(mo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::ServerInterface* servant = dynamic_cast< ::Bomberloutre::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->addGame(_m_name, _m_room, _m_mo, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Bomberloutre::GameInterfacePrx& _result;
        const ::std::string& _m_name;
        const ::Bomberloutre::GameWaitRoomPrx& _m_room;
        const ::Bomberloutre::MapObserverPrx& _m_mo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__ServerInterface__addGame_name, ::Ice::Normal, __context);
    ::Bomberloutre::GameInterfacePrx __result;
    try
    {
        _DirectI __direct(__result, name, room, mo, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Bomberloutre::Map
IceDelegateD::Bomberloutre::ServerInterface::joinGame(const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Bomberloutre::Map& __result, const ::std::string& name, const ::Bomberloutre::GameWaitRoomPrx& room, const ::Bomberloutre::MapObserverPrx& mo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_name(name),
            _m_room(room),
            _m_mo(mo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::ServerInterface* servant = dynamic_cast< ::Bomberloutre::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->joinGame(_m_name, _m_room, _m_mo, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Bomberloutre::Map& _result;
        const ::std::string& _m_name;
        const ::Bomberloutre::GameWaitRoomPrx& _m_room;
        const ::Bomberloutre::MapObserverPrx& _m_mo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__ServerInterface__joinGame_name, ::Ice::Normal, __context);
    ::Bomberloutre::Map __result;
    try
    {
        _DirectI __direct(__result, name, room, mo, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Bomberloutre::GameDataList
IceDelegateD::Bomberloutre::ServerInterface::getGameList(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Bomberloutre::GameDataList& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::ServerInterface* servant = dynamic_cast< ::Bomberloutre::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getGameList(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Bomberloutre::GameDataList& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__ServerInterface__getGameList_name, ::Ice::Normal, __context);
    ::Bomberloutre::GameDataList __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Bomberloutre::UserDataList
IceDelegateD::Bomberloutre::ServerInterface::getUserList(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Bomberloutre::UserDataList& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Bomberloutre::ServerInterface* servant = dynamic_cast< ::Bomberloutre::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getUserList(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Bomberloutre::UserDataList& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Bomberloutre__ServerInterface__getUserList_name, ::Ice::Normal, __context);
    ::Bomberloutre::UserDataList __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::ObjectPtr
Bomberloutre::GameInterface::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __Bomberloutre__GameInterface_ids[2] =
{
    "::Bomberloutre::GameInterface",
    "::Ice::Object"
};

bool
Bomberloutre::GameInterface::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__GameInterface_ids, __Bomberloutre__GameInterface_ids + 2, _s);
}

::std::vector< ::std::string>
Bomberloutre::GameInterface::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__GameInterface_ids[0], &__Bomberloutre__GameInterface_ids[2]);
}

const ::std::string&
Bomberloutre::GameInterface::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__GameInterface_ids[0];
}

const ::std::string&
Bomberloutre::GameInterface::ice_staticId()
{
    return __Bomberloutre__GameInterface_ids[0];
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___getName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getName(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___getState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getState(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___getRoundCount(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getRoundCount(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___setName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string newname;
    __is->read(newname);
    __is->endReadEncaps();
    setName(newname, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___setState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int newstate;
    __is->read(newstate);
    __is->endReadEncaps();
    setState(newstate, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___setRoundCount(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int newcount;
    __is->read(newcount);
    __is->endReadEncaps();
    setRoundCount(newcount, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___kickPlayer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    kickPlayer(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___invitePlayer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    invitePlayer(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___addBot(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    addBot(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___removeBot(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    removeBot(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___createMap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string mode;
    ::std::string mapSkin;
    __is->read(mode);
    __is->read(mapSkin);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = createMap(mode, mapSkin, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___startMap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    startMap(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___endMap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    endMap(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameInterface::___removeGame(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = removeGame(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

static ::std::string __Bomberloutre__GameInterface_all[] =
{
    "addBot",
    "createMap",
    "endMap",
    "getName",
    "getRoundCount",
    "getState",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "invitePlayer",
    "kickPlayer",
    "removeBot",
    "removeGame",
    "setName",
    "setRoundCount",
    "setState",
    "startMap"
};

::Ice::DispatchStatus
Bomberloutre::GameInterface::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__Bomberloutre__GameInterface_all, __Bomberloutre__GameInterface_all + 18, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Bomberloutre__GameInterface_all)
    {
        case 0:
        {
            return ___addBot(in, current);
        }
        case 1:
        {
            return ___createMap(in, current);
        }
        case 2:
        {
            return ___endMap(in, current);
        }
        case 3:
        {
            return ___getName(in, current);
        }
        case 4:
        {
            return ___getRoundCount(in, current);
        }
        case 5:
        {
            return ___getState(in, current);
        }
        case 6:
        {
            return ___ice_id(in, current);
        }
        case 7:
        {
            return ___ice_ids(in, current);
        }
        case 8:
        {
            return ___ice_isA(in, current);
        }
        case 9:
        {
            return ___ice_ping(in, current);
        }
        case 10:
        {
            return ___invitePlayer(in, current);
        }
        case 11:
        {
            return ___kickPlayer(in, current);
        }
        case 12:
        {
            return ___removeBot(in, current);
        }
        case 13:
        {
            return ___removeGame(in, current);
        }
        case 14:
        {
            return ___setName(in, current);
        }
        case 15:
        {
            return ___setRoundCount(in, current);
        }
        case 16:
        {
            return ___setState(in, current);
        }
        case 17:
        {
            return ___startMap(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Bomberloutre::GameInterface::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
Bomberloutre::GameInterface::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::GameInterface::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::GameInterface was not generated with stream support";
    throw ex;
}

void
Bomberloutre::GameInterface::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::GameInterface was not generated with stream support";
    throw ex;
}
#endif

void 
Bomberloutre::__patch__GameInterfacePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::GameInterfacePtr* p = static_cast< ::Bomberloutre::GameInterfacePtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::GameInterfacePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::GameInterface::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
Bomberloutre::GameWaitRoom::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __Bomberloutre__GameWaitRoom_ids[2] =
{
    "::Bomberloutre::GameWaitRoom",
    "::Ice::Object"
};

bool
Bomberloutre::GameWaitRoom::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__GameWaitRoom_ids, __Bomberloutre__GameWaitRoom_ids + 2, _s);
}

::std::vector< ::std::string>
Bomberloutre::GameWaitRoom::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__GameWaitRoom_ids[0], &__Bomberloutre__GameWaitRoom_ids[2]);
}

const ::std::string&
Bomberloutre::GameWaitRoom::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__GameWaitRoom_ids[0];
}

const ::std::string&
Bomberloutre::GameWaitRoom::ice_staticId()
{
    return __Bomberloutre__GameWaitRoom_ids[0];
}

::Ice::DispatchStatus
Bomberloutre::GameWaitRoom::___newUserInRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    newUserInRoom(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameWaitRoom::___userLeftRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    userLeftRoom(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameWaitRoom::___allUsersReady(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    allUsersReady(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameWaitRoom::___userReady(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    userReady(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameWaitRoom::___gameStart(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    gameStart(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::GameWaitRoom::___gameEnd(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    gameEnd(__current);
    return ::Ice::DispatchOK;
}

static ::std::string __Bomberloutre__GameWaitRoom_all[] =
{
    "allUsersReady",
    "gameEnd",
    "gameStart",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newUserInRoom",
    "userLeftRoom",
    "userReady"
};

::Ice::DispatchStatus
Bomberloutre::GameWaitRoom::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__Bomberloutre__GameWaitRoom_all, __Bomberloutre__GameWaitRoom_all + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Bomberloutre__GameWaitRoom_all)
    {
        case 0:
        {
            return ___allUsersReady(in, current);
        }
        case 1:
        {
            return ___gameEnd(in, current);
        }
        case 2:
        {
            return ___gameStart(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
        case 7:
        {
            return ___newUserInRoom(in, current);
        }
        case 8:
        {
            return ___userLeftRoom(in, current);
        }
        case 9:
        {
            return ___userReady(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Bomberloutre::GameWaitRoom::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
Bomberloutre::GameWaitRoom::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::GameWaitRoom::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::GameWaitRoom was not generated with stream support";
    throw ex;
}

void
Bomberloutre::GameWaitRoom::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::GameWaitRoom was not generated with stream support";
    throw ex;
}
#endif

void 
Bomberloutre::__patch__GameWaitRoomPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::GameWaitRoomPtr* p = static_cast< ::Bomberloutre::GameWaitRoomPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::GameWaitRoomPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::GameWaitRoom::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
Bomberloutre::MapInterface::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __Bomberloutre__MapInterface_ids[2] =
{
    "::Bomberloutre::MapInterface",
    "::Ice::Object"
};

bool
Bomberloutre::MapInterface::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__MapInterface_ids, __Bomberloutre__MapInterface_ids + 2, _s);
}

::std::vector< ::std::string>
Bomberloutre::MapInterface::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__MapInterface_ids[0], &__Bomberloutre__MapInterface_ids[2]);
}

const ::std::string&
Bomberloutre::MapInterface::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__MapInterface_ids[0];
}

const ::std::string&
Bomberloutre::MapInterface::ice_staticId()
{
    return __Bomberloutre__MapInterface_ids[0];
}

::Ice::DispatchStatus
Bomberloutre::MapInterface::___getId(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getId(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapInterface::___getWidth(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getWidth(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapInterface::___getHeight(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getHeight(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapInterface::___move(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Bomberloutre::Player p;
    ::Bomberloutre::Point pt;
    p.__read(__is);
    pt.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = move(p, pt, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapInterface::___kickBomb(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Bomberloutre::Player p;
    p.__read(__is);
    __is->endReadEncaps();
    kickBomb(p, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapInterface::___dropBomb(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Bomberloutre::Player p;
    ::Bomberloutre::BombPtr b;
    p.__read(__is);
    __is->read(::Bomberloutre::__patch__BombPtr, &b);
    __is->readPendingObjects();
    __is->endReadEncaps();
    dropBomb(p, b, __current);
    return ::Ice::DispatchOK;
}

static ::std::string __Bomberloutre__MapInterface_all[] =
{
    "dropBomb",
    "getHeight",
    "getId",
    "getWidth",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "kickBomb",
    "move"
};

::Ice::DispatchStatus
Bomberloutre::MapInterface::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__Bomberloutre__MapInterface_all, __Bomberloutre__MapInterface_all + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Bomberloutre__MapInterface_all)
    {
        case 0:
        {
            return ___dropBomb(in, current);
        }
        case 1:
        {
            return ___getHeight(in, current);
        }
        case 2:
        {
            return ___getId(in, current);
        }
        case 3:
        {
            return ___getWidth(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
        case 8:
        {
            return ___kickBomb(in, current);
        }
        case 9:
        {
            return ___move(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Bomberloutre::MapInterface::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
Bomberloutre::MapInterface::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::MapInterface::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::MapInterface was not generated with stream support";
    throw ex;
}

void
Bomberloutre::MapInterface::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::MapInterface was not generated with stream support";
    throw ex;
}
#endif

void 
Bomberloutre::__patch__MapInterfacePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::MapInterfacePtr* p = static_cast< ::Bomberloutre::MapInterfacePtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::MapInterfacePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::MapInterface::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
Bomberloutre::MapObserver::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __Bomberloutre__MapObserver_ids[2] =
{
    "::Bomberloutre::MapObserver",
    "::Ice::Object"
};

bool
Bomberloutre::MapObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__MapObserver_ids, __Bomberloutre__MapObserver_ids + 2, _s);
}

::std::vector< ::std::string>
Bomberloutre::MapObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__MapObserver_ids[0], &__Bomberloutre__MapObserver_ids[2]);
}

const ::std::string&
Bomberloutre::MapObserver::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__MapObserver_ids[0];
}

const ::std::string&
Bomberloutre::MapObserver::ice_staticId()
{
    return __Bomberloutre__MapObserver_ids[0];
}

::Ice::DispatchStatus
Bomberloutre::MapObserver::___refreshMapItems(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Bomberloutre::MapItems mi;
    ::Bomberloutre::__readMapItems(__is, mi);
    __is->readPendingObjects();
    __is->endReadEncaps();
    refreshMapItems(mi, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapObserver::___refreshPlayers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Bomberloutre::PlayerList p;
    ::Bomberloutre::__readPlayerList(__is, p);
    __is->endReadEncaps();
    refreshPlayers(p, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapObserver::___bombHasBeenPlanted(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Bomberloutre::BombPtr b;
    __is->read(::Bomberloutre::__patch__BombPtr, &b);
    __is->readPendingObjects();
    __is->endReadEncaps();
    bombHasBeenPlanted(b, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapObserver::___bombExploded(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Bomberloutre::BombPtr b;
    __is->read(::Bomberloutre::__patch__BombPtr, &b);
    __is->readPendingObjects();
    __is->endReadEncaps();
    bombExploded(b, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::MapObserver::___bonusesDropped(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Bomberloutre::Bonuses b;
    ::Bomberloutre::__readBonuses(__is, b);
    __is->readPendingObjects();
    __is->endReadEncaps();
    bonusesDropped(b, __current);
    return ::Ice::DispatchOK;
}

static ::std::string __Bomberloutre__MapObserver_all[] =
{
    "bombExploded",
    "bombHasBeenPlanted",
    "bonusesDropped",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "refreshMapItems",
    "refreshPlayers"
};

::Ice::DispatchStatus
Bomberloutre::MapObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__Bomberloutre__MapObserver_all, __Bomberloutre__MapObserver_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Bomberloutre__MapObserver_all)
    {
        case 0:
        {
            return ___bombExploded(in, current);
        }
        case 1:
        {
            return ___bombHasBeenPlanted(in, current);
        }
        case 2:
        {
            return ___bonusesDropped(in, current);
        }
        case 3:
        {
            return ___ice_id(in, current);
        }
        case 4:
        {
            return ___ice_ids(in, current);
        }
        case 5:
        {
            return ___ice_isA(in, current);
        }
        case 6:
        {
            return ___ice_ping(in, current);
        }
        case 7:
        {
            return ___refreshMapItems(in, current);
        }
        case 8:
        {
            return ___refreshPlayers(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Bomberloutre::MapObserver::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
Bomberloutre::MapObserver::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::MapObserver::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::MapObserver was not generated with stream support";
    throw ex;
}

void
Bomberloutre::MapObserver::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::MapObserver was not generated with stream support";
    throw ex;
}
#endif

void 
Bomberloutre::__patch__MapObserverPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::MapObserverPtr* p = static_cast< ::Bomberloutre::MapObserverPtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::MapObserverPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::MapObserver::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
Bomberloutre::ServerInterface::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __Bomberloutre__ServerInterface_ids[2] =
{
    "::Bomberloutre::ServerInterface",
    "::Ice::Object"
};

bool
Bomberloutre::ServerInterface::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Bomberloutre__ServerInterface_ids, __Bomberloutre__ServerInterface_ids + 2, _s);
}

::std::vector< ::std::string>
Bomberloutre::ServerInterface::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Bomberloutre__ServerInterface_ids[0], &__Bomberloutre__ServerInterface_ids[2]);
}

const ::std::string&
Bomberloutre::ServerInterface::ice_id(const ::Ice::Current&) const
{
    return __Bomberloutre__ServerInterface_ids[0];
}

const ::std::string&
Bomberloutre::ServerInterface::ice_staticId()
{
    return __Bomberloutre__ServerInterface_ids[0];
}

::Ice::DispatchStatus
Bomberloutre::ServerInterface::___connect(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string login;
    ::std::string password;
    __is->read(login);
    __is->read(password);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::Bomberloutre::UserData __ret = connect(login, password, __current);
        __ret.__write(__os);
    }
    catch(const ::Bomberloutre::BadLoginException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    catch(const ::Bomberloutre::BadPasswordException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::ServerInterface::___createUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string login;
    ::std::string password;
    __is->read(login);
    __is->read(password);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::Bomberloutre::UserData __ret = createUser(login, password, __current);
        __ret.__write(__os);
    }
    catch(const ::Bomberloutre::UserAlreadyExistsException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::ServerInterface::___deleteUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string login;
    __is->read(login);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = deleteUser(login, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::ServerInterface::___addGame(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string name;
    ::Bomberloutre::GameWaitRoomPrx room;
    ::Bomberloutre::MapObserverPrx mo;
    __is->read(name);
    ::Bomberloutre::__read(__is, room);
    ::Bomberloutre::__read(__is, mo);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Bomberloutre::GameInterfacePrx __ret = addGame(name, room, mo, __current);
    __os->write(::Ice::ObjectPrx(::IceInternal::upCast(__ret.get())));
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::ServerInterface::___joinGame(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string name;
    ::Bomberloutre::GameWaitRoomPrx room;
    ::Bomberloutre::MapObserverPrx mo;
    __is->read(name);
    ::Bomberloutre::__read(__is, room);
    ::Bomberloutre::__read(__is, mo);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Bomberloutre::Map __ret = joinGame(name, room, mo, __current);
    __ret.__write(__os);
    __os->writePendingObjects();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::ServerInterface::___getGameList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Bomberloutre::GameDataList __ret = getGameList(__current);
    if(__ret.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::Bomberloutre::__writeGameDataList(__os, &__ret[0], &__ret[0] + __ret.size());
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Bomberloutre::ServerInterface::___getUserList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Bomberloutre::UserDataList __ret = getUserList(__current);
    if(__ret.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::Bomberloutre::__writeUserDataList(__os, &__ret[0], &__ret[0] + __ret.size());
    }
    return ::Ice::DispatchOK;
}

static ::std::string __Bomberloutre__ServerInterface_all[] =
{
    "addGame",
    "connect",
    "createUser",
    "deleteUser",
    "getGameList",
    "getUserList",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "joinGame"
};

::Ice::DispatchStatus
Bomberloutre::ServerInterface::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__Bomberloutre__ServerInterface_all, __Bomberloutre__ServerInterface_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Bomberloutre__ServerInterface_all)
    {
        case 0:
        {
            return ___addGame(in, current);
        }
        case 1:
        {
            return ___connect(in, current);
        }
        case 2:
        {
            return ___createUser(in, current);
        }
        case 3:
        {
            return ___deleteUser(in, current);
        }
        case 4:
        {
            return ___getGameList(in, current);
        }
        case 5:
        {
            return ___getUserList(in, current);
        }
        case 6:
        {
            return ___ice_id(in, current);
        }
        case 7:
        {
            return ___ice_ids(in, current);
        }
        case 8:
        {
            return ___ice_isA(in, current);
        }
        case 9:
        {
            return ___ice_ping(in, current);
        }
        case 10:
        {
            return ___joinGame(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Bomberloutre::ServerInterface::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
Bomberloutre::ServerInterface::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
Bomberloutre::ServerInterface::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::ServerInterface was not generated with stream support";
    throw ex;
}

void
Bomberloutre::ServerInterface::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type Bomberloutre::ServerInterface was not generated with stream support";
    throw ex;
}
#endif

void 
Bomberloutre::__patch__ServerInterfacePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::Bomberloutre::ServerInterfacePtr* p = static_cast< ::Bomberloutre::ServerInterfacePtr*>(__addr);
    assert(p);
    *p = ::Bomberloutre::ServerInterfacePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::Bomberloutre::ServerInterface::ice_staticId(), v->ice_id());
    }
}
