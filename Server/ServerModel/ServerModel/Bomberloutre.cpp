// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Bomberloutre.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Bomberloutre.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __BomberLoutreInterface__GameUserInterface__getCreatorName_name = "getCreatorName";

static const ::std::string __BomberLoutreInterface__GameUserInterface__userReady_name = "userReady";

static const ::std::string __BomberLoutreInterface__GameUserInterface__leaveGame_name = "leaveGame";

static const ::std::string __BomberLoutreInterface__GameInterface__getName_name = "getName";

static const ::std::string __BomberLoutreInterface__GameInterface__getState_name = "getState";

static const ::std::string __BomberLoutreInterface__GameInterface__getRoundCount_name = "getRoundCount";

static const ::std::string __BomberLoutreInterface__GameInterface__setName_name = "setName";

static const ::std::string __BomberLoutreInterface__GameInterface__setState_name = "setState";

static const ::std::string __BomberLoutreInterface__GameInterface__setRoundCount_name = "setRoundCount";

static const ::std::string __BomberLoutreInterface__GameInterface__kickPlayer_name = "kickPlayer";

static const ::std::string __BomberLoutreInterface__GameInterface__invitePlayer_name = "invitePlayer";

static const ::std::string __BomberLoutreInterface__GameInterface__addBot_name = "addBot";

static const ::std::string __BomberLoutreInterface__GameInterface__removeBot_name = "removeBot";

static const ::std::string __BomberLoutreInterface__GameInterface__getMapList_name = "getMapList";

static const ::std::string __BomberLoutreInterface__GameInterface__createMap_name = "createMap";

static const ::std::string __BomberLoutreInterface__GameInterface__startMap_name = "startMap";

static const ::std::string __BomberLoutreInterface__GameInterface__endMap_name = "endMap";

static const ::std::string __BomberLoutreInterface__GameInterface__removeGame_name = "removeGame";

static const ::std::string __BomberLoutreInterface__GameWaitRoom__newUserInRoom_name = "newUserInRoom";

static const ::std::string __BomberLoutreInterface__GameWaitRoom__userLeftRoom_name = "userLeftRoom";

static const ::std::string __BomberLoutreInterface__GameWaitRoom__allUsersReady_name = "allUsersReady";

static const ::std::string __BomberLoutreInterface__GameWaitRoom__userReady_name = "userReady";

static const ::std::string __BomberLoutreInterface__GameWaitRoom__gameDataUpdated_name = "gameDataUpdated";

static const ::std::string __BomberLoutreInterface__GameWaitRoom__newMapDefined_name = "newMapDefined";

static const ::std::string __BomberLoutreInterface__GameWaitRoom__gameStart_name = "gameStart";

static const ::std::string __BomberLoutreInterface__GameWaitRoom__gameEnd_name = "gameEnd";

static const ::std::string __BomberLoutreInterface__MapInterface__getId_name = "getId";

static const ::std::string __BomberLoutreInterface__MapInterface__getWidth_name = "getWidth";

static const ::std::string __BomberLoutreInterface__MapInterface__getHeight_name = "getHeight";

static const ::std::string __BomberLoutreInterface__MapInterface__moveUp_name = "moveUp";

static const ::std::string __BomberLoutreInterface__MapInterface__moveDown_name = "moveDown";

static const ::std::string __BomberLoutreInterface__MapInterface__moveLeft_name = "moveLeft";

static const ::std::string __BomberLoutreInterface__MapInterface__moveRight_name = "moveRight";

static const ::std::string __BomberLoutreInterface__MapInterface__dropBomb_name = "dropBomb";

static const ::std::string __BomberLoutreInterface__MapObserver__refreshMapItems_name = "refreshMapItems";

static const ::std::string __BomberLoutreInterface__MapObserver__refreshPlayers_name = "refreshPlayers";

static const ::std::string __BomberLoutreInterface__MapObserver__bombHasBeenPlanted_name = "bombHasBeenPlanted";

static const ::std::string __BomberLoutreInterface__MapObserver__bombExploded_name = "bombExploded";

static const ::std::string __BomberLoutreInterface__MapObserver__bombKicked_name = "bombKicked";

static const ::std::string __BomberLoutreInterface__MapObserver__bonusesDropped_name = "bonusesDropped";

static const ::std::string __BomberLoutreInterface__MapObserver__playerDied_name = "playerDied";

static const ::std::string __BomberLoutreInterface__ServerInterface__connect_name = "connect";

static const ::std::string __BomberLoutreInterface__ServerInterface__createUser_name = "createUser";

static const ::std::string __BomberLoutreInterface__ServerInterface__deleteUser_name = "deleteUser";

static const ::std::string __BomberLoutreInterface__ServerInterface__addGame_name = "addGame";

static const ::std::string __BomberLoutreInterface__ServerInterface__joinGame_name = "joinGame";

static const ::std::string __BomberLoutreInterface__ServerInterface__getGameList_name = "getGameList";

static const ::std::string __BomberLoutreInterface__ServerInterface__getUserList_name = "getUserList";

::Ice::Object* IceInternal::upCast(::BomberLoutreInterface::GameUserInterface* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::BomberLoutreInterface::GameUserInterface* p) { return p; }

::Ice::Object* IceInternal::upCast(::BomberLoutreInterface::GameInterface* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::BomberLoutreInterface::GameInterface* p) { return p; }

::Ice::Object* IceInternal::upCast(::BomberLoutreInterface::GameWaitRoom* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::BomberLoutreInterface::GameWaitRoom* p) { return p; }

::Ice::Object* IceInternal::upCast(::BomberLoutreInterface::MapInterface* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::BomberLoutreInterface::MapInterface* p) { return p; }

::Ice::Object* IceInternal::upCast(::BomberLoutreInterface::MapObserver* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::BomberLoutreInterface::MapObserver* p) { return p; }

::Ice::Object* IceInternal::upCast(::BomberLoutreInterface::ServerInterface* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::BomberLoutreInterface::ServerInterface* p) { return p; }

void
BomberLoutreInterface::__read(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::GameUserInterfacePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BomberLoutreInterface::GameUserInterface;
        v->__copyFrom(proxy);
    }
}

void
BomberLoutreInterface::__read(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::GameInterfacePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BomberLoutreInterface::GameInterface;
        v->__copyFrom(proxy);
    }
}

void
BomberLoutreInterface::__read(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::GameWaitRoomPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BomberLoutreInterface::GameWaitRoom;
        v->__copyFrom(proxy);
    }
}

void
BomberLoutreInterface::__read(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::MapInterfacePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BomberLoutreInterface::MapInterface;
        v->__copyFrom(proxy);
    }
}

void
BomberLoutreInterface::__read(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::MapObserverPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BomberLoutreInterface::MapObserver;
        v->__copyFrom(proxy);
    }
}

void
BomberLoutreInterface::__read(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::ServerInterfacePrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BomberLoutreInterface::ServerInterface;
        v->__copyFrom(proxy);
    }
}

void
BomberLoutreInterface::UserData::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(gameTag);
    __os->write(gameCount);
    __os->write(winCount);
    __os->write(drawCount);
    __os->write(killCount);
    __os->write(deathCount);
    __os->write(suicideCount);
}

void
BomberLoutreInterface::UserData::__read(::IceInternal::BasicStream* __is)
{
    __is->read(gameTag);
    __is->read(gameCount);
    __is->read(winCount);
    __is->read(drawCount);
    __is->read(killCount);
    __is->read(deathCount);
    __is->read(suicideCount);
}

void
BomberLoutreInterface::__writeUserDataList(::IceInternal::BasicStream* __os, const ::BomberLoutreInterface::UserData* begin, const ::BomberLoutreInterface::UserData* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
BomberLoutreInterface::__readUserDataList(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::UserDataList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(25, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
BomberLoutreInterface::GameData::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(name);
    __os->write(roundCount);
    __os->write(state);
    __os->write(playerCount);
    __os->write(::Ice::ObjectPrx(::IceInternal::upCast(gameui.get())));
}

void
BomberLoutreInterface::GameData::__read(::IceInternal::BasicStream* __is)
{
    __is->read(name);
    __is->read(roundCount);
    __is->read(state);
    __is->read(playerCount);
    ::BomberLoutreInterface::__read(__is, gameui);
}

void
BomberLoutreInterface::__writeGameDataList(::IceInternal::BasicStream* __os, const ::BomberLoutreInterface::GameData* begin, const ::BomberLoutreInterface::GameData* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
BomberLoutreInterface::__readGameDataList(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::GameDataList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(15, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
BomberLoutreInterface::Player::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(posX);
    __os->write(posY);
    __os->write(width);
    __os->write(height);
    __os->write(killCount);
    __os->write(deathCount);
    __os->write(suicideCount);
    related.__write(__os);
}

void
BomberLoutreInterface::Player::__read(::IceInternal::BasicStream* __is)
{
    __is->read(posX);
    __is->read(posY);
    __is->read(width);
    __is->read(height);
    __is->read(killCount);
    __is->read(deathCount);
    __is->read(suicideCount);
    related.__read(__is);
}

void
BomberLoutreInterface::__writePlayerList(::IceInternal::BasicStream* __os, const ::BomberLoutreInterface::Player* begin, const ::BomberLoutreInterface::Player* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
BomberLoutreInterface::__readPlayerList(::IceInternal::BasicStream* __is, ::BomberLoutreInterface::PlayerList& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(53, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
BomberLoutreInterface::Point::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(x);
    __os->write(y);
}

void
BomberLoutreInterface::Point::__read(::IceInternal::BasicStream* __is)
{
    __is->read(x);
    __is->read(y);
}

void
BomberLoutreInterface::Map::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mi.get())));
    if(items.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::BomberLoutreInterface::__writeMapItems(__os, &items[0], &items[0] + items.size());
    }
    if(players.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::BomberLoutreInterface::__writePlayerList(__os, &players[0], &players[0] + players.size());
    }
}

void
BomberLoutreInterface::Map::__read(::IceInternal::BasicStream* __is)
{
    ::BomberLoutreInterface::__read(__is, mi);
    ::BomberLoutreInterface::__readMapItems(__is, items);
    ::BomberLoutreInterface::__readPlayerList(__is, players);
}

BomberLoutreInterface::UserException::UserException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(),
#else
    ::Ice::UserException(),
#endif
    reason(__ice_reason)
{
}

BomberLoutreInterface::UserException::~UserException() throw()
{
}

static const char* __BomberLoutreInterface__UserException_name = "BomberLoutreInterface::UserException";

::std::string
BomberLoutreInterface::UserException::ice_name() const
{
    return __BomberLoutreInterface__UserException_name;
}

::Ice::Exception*
BomberLoutreInterface::UserException::ice_clone() const
{
    return new UserException(*this);
}

void
BomberLoutreInterface::UserException::ice_throw() const
{
    throw *this;
}

void
BomberLoutreInterface::UserException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::BomberLoutreInterface::UserException"), false);
    __os->startWriteSlice();
    __os->write(reason);
    __os->endWriteSlice();
}

void
BomberLoutreInterface::UserException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->read(reason);
    __is->endReadSlice();
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::UserException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception BomberLoutreInterface::UserException was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::UserException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception BomberLoutreInterface::UserException was not generated with stream support";
    throw ex;
}
#endif

struct __F__BomberLoutreInterface__UserException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::BomberLoutreInterface::UserException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__BomberLoutreInterface__UserException__Ptr = new __F__BomberLoutreInterface__UserException;

const ::IceInternal::UserExceptionFactoryPtr&
BomberLoutreInterface::UserException::ice_factory()
{
    return __F__BomberLoutreInterface__UserException__Ptr;
}

class __F__BomberLoutreInterface__UserException__Init
{
public:

    __F__BomberLoutreInterface__UserException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::BomberLoutreInterface::UserException", ::BomberLoutreInterface::UserException::ice_factory());
    }

    ~__F__BomberLoutreInterface__UserException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::BomberLoutreInterface::UserException");
    }
};

static __F__BomberLoutreInterface__UserException__Init __F__BomberLoutreInterface__UserException__i;

#ifdef __APPLE__
extern "C" { void __F__BomberLoutreInterface__UserException__initializer() {} }
#endif

BomberLoutreInterface::BadLoginException::BadLoginException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(__ice_reason)
#else
    ::BomberLoutreInterface::UserException(__ice_reason)
#endif
{
}

BomberLoutreInterface::BadLoginException::~BadLoginException() throw()
{
}

static const char* __BomberLoutreInterface__BadLoginException_name = "BomberLoutreInterface::BadLoginException";

::std::string
BomberLoutreInterface::BadLoginException::ice_name() const
{
    return __BomberLoutreInterface__BadLoginException_name;
}

::Ice::Exception*
BomberLoutreInterface::BadLoginException::ice_clone() const
{
    return new BadLoginException(*this);
}

void
BomberLoutreInterface::BadLoginException::ice_throw() const
{
    throw *this;
}

void
BomberLoutreInterface::BadLoginException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::BomberLoutreInterface::BadLoginException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__write(__os);
#else
    ::BomberLoutreInterface::UserException::__write(__os);
#endif
}

void
BomberLoutreInterface::BadLoginException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__read(__is, true);
#else
    ::BomberLoutreInterface::UserException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::BadLoginException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception BomberLoutreInterface::BadLoginException was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::BadLoginException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception BomberLoutreInterface::BadLoginException was not generated with stream support";
    throw ex;
}
#endif

struct __F__BomberLoutreInterface__BadLoginException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::BomberLoutreInterface::BadLoginException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__BomberLoutreInterface__BadLoginException__Ptr = new __F__BomberLoutreInterface__BadLoginException;

const ::IceInternal::UserExceptionFactoryPtr&
BomberLoutreInterface::BadLoginException::ice_factory()
{
    return __F__BomberLoutreInterface__BadLoginException__Ptr;
}

class __F__BomberLoutreInterface__BadLoginException__Init
{
public:

    __F__BomberLoutreInterface__BadLoginException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::BomberLoutreInterface::BadLoginException", ::BomberLoutreInterface::BadLoginException::ice_factory());
    }

    ~__F__BomberLoutreInterface__BadLoginException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::BomberLoutreInterface::BadLoginException");
    }
};

static __F__BomberLoutreInterface__BadLoginException__Init __F__BomberLoutreInterface__BadLoginException__i;

#ifdef __APPLE__
extern "C" { void __F__BomberLoutreInterface__BadLoginException__initializer() {} }
#endif

BomberLoutreInterface::BadPasswordException::BadPasswordException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(__ice_reason)
#else
    ::BomberLoutreInterface::UserException(__ice_reason)
#endif
{
}

BomberLoutreInterface::BadPasswordException::~BadPasswordException() throw()
{
}

static const char* __BomberLoutreInterface__BadPasswordException_name = "BomberLoutreInterface::BadPasswordException";

::std::string
BomberLoutreInterface::BadPasswordException::ice_name() const
{
    return __BomberLoutreInterface__BadPasswordException_name;
}

::Ice::Exception*
BomberLoutreInterface::BadPasswordException::ice_clone() const
{
    return new BadPasswordException(*this);
}

void
BomberLoutreInterface::BadPasswordException::ice_throw() const
{
    throw *this;
}

void
BomberLoutreInterface::BadPasswordException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::BomberLoutreInterface::BadPasswordException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__write(__os);
#else
    ::BomberLoutreInterface::UserException::__write(__os);
#endif
}

void
BomberLoutreInterface::BadPasswordException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__read(__is, true);
#else
    ::BomberLoutreInterface::UserException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::BadPasswordException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception BomberLoutreInterface::BadPasswordException was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::BadPasswordException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception BomberLoutreInterface::BadPasswordException was not generated with stream support";
    throw ex;
}
#endif

struct __F__BomberLoutreInterface__BadPasswordException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::BomberLoutreInterface::BadPasswordException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__BomberLoutreInterface__BadPasswordException__Ptr = new __F__BomberLoutreInterface__BadPasswordException;

const ::IceInternal::UserExceptionFactoryPtr&
BomberLoutreInterface::BadPasswordException::ice_factory()
{
    return __F__BomberLoutreInterface__BadPasswordException__Ptr;
}

class __F__BomberLoutreInterface__BadPasswordException__Init
{
public:

    __F__BomberLoutreInterface__BadPasswordException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::BomberLoutreInterface::BadPasswordException", ::BomberLoutreInterface::BadPasswordException::ice_factory());
    }

    ~__F__BomberLoutreInterface__BadPasswordException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::BomberLoutreInterface::BadPasswordException");
    }
};

static __F__BomberLoutreInterface__BadPasswordException__Init __F__BomberLoutreInterface__BadPasswordException__i;

#ifdef __APPLE__
extern "C" { void __F__BomberLoutreInterface__BadPasswordException__initializer() {} }
#endif

BomberLoutreInterface::UserAlreadyExistsException::UserAlreadyExistsException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(__ice_reason)
#else
    ::BomberLoutreInterface::UserException(__ice_reason)
#endif
{
}

BomberLoutreInterface::UserAlreadyExistsException::~UserAlreadyExistsException() throw()
{
}

static const char* __BomberLoutreInterface__UserAlreadyExistsException_name = "BomberLoutreInterface::UserAlreadyExistsException";

::std::string
BomberLoutreInterface::UserAlreadyExistsException::ice_name() const
{
    return __BomberLoutreInterface__UserAlreadyExistsException_name;
}

::Ice::Exception*
BomberLoutreInterface::UserAlreadyExistsException::ice_clone() const
{
    return new UserAlreadyExistsException(*this);
}

void
BomberLoutreInterface::UserAlreadyExistsException::ice_throw() const
{
    throw *this;
}

void
BomberLoutreInterface::UserAlreadyExistsException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::BomberLoutreInterface::UserAlreadyExistsException"), false);
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__write(__os);
#else
    ::BomberLoutreInterface::UserException::__write(__os);
#endif
}

void
BomberLoutreInterface::UserAlreadyExistsException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException::__read(__is, true);
#else
    ::BomberLoutreInterface::UserException::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::UserAlreadyExistsException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception BomberLoutreInterface::UserAlreadyExistsException was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::UserAlreadyExistsException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception BomberLoutreInterface::UserAlreadyExistsException was not generated with stream support";
    throw ex;
}
#endif

struct __F__BomberLoutreInterface__UserAlreadyExistsException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::BomberLoutreInterface::UserAlreadyExistsException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__BomberLoutreInterface__UserAlreadyExistsException__Ptr = new __F__BomberLoutreInterface__UserAlreadyExistsException;

const ::IceInternal::UserExceptionFactoryPtr&
BomberLoutreInterface::UserAlreadyExistsException::ice_factory()
{
    return __F__BomberLoutreInterface__UserAlreadyExistsException__Ptr;
}

class __F__BomberLoutreInterface__UserAlreadyExistsException__Init
{
public:

    __F__BomberLoutreInterface__UserAlreadyExistsException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::BomberLoutreInterface::UserAlreadyExistsException", ::BomberLoutreInterface::UserAlreadyExistsException::ice_factory());
    }

    ~__F__BomberLoutreInterface__UserAlreadyExistsException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::BomberLoutreInterface::UserAlreadyExistsException");
    }
};

static __F__BomberLoutreInterface__UserAlreadyExistsException__Init __F__BomberLoutreInterface__UserAlreadyExistsException__i;

#ifdef __APPLE__
extern "C" { void __F__BomberLoutreInterface__UserAlreadyExistsException__initializer() {} }
#endif

::std::string
IceProxy::BomberLoutreInterface::GameUserInterface::getCreatorName(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__GameUserInterface__getCreatorName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameUserInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameUserInterface*>(__delBase.get());
            return __del->getCreatorName(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameUserInterface::begin_getCreatorName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__GameUserInterface__getCreatorName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameUserInterface__getCreatorName_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameUserInterface__getCreatorName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::BomberLoutreInterface::GameUserInterface::end_getCreatorName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__GameUserInterface__getCreatorName_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::BomberLoutreInterface::GameUserInterface::userReady(const ::BomberLoutreInterface::UserData& u, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameUserInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameUserInterface*>(__delBase.get());
            __del->userReady(u, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameUserInterface::begin_userReady(const ::BomberLoutreInterface::UserData& u, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameUserInterface__userReady_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameUserInterface__userReady_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        u.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameUserInterface::end_userReady(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameUserInterface__userReady_name);
}

void
IceProxy::BomberLoutreInterface::GameUserInterface::leaveGame(const ::BomberLoutreInterface::UserData& u, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameUserInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameUserInterface*>(__delBase.get());
            __del->leaveGame(u, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameUserInterface::begin_leaveGame(const ::BomberLoutreInterface::UserData& u, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameUserInterface__leaveGame_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameUserInterface__leaveGame_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        u.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameUserInterface::end_leaveGame(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameUserInterface__leaveGame_name);
}

const ::std::string&
IceProxy::BomberLoutreInterface::GameUserInterface::ice_staticId()
{
    return ::BomberLoutreInterface::GameUserInterface::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::BomberLoutreInterface::GameUserInterface::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::BomberLoutreInterface::GameUserInterface);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::BomberLoutreInterface::GameUserInterface::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::BomberLoutreInterface::GameUserInterface);
}

::IceProxy::Ice::Object*
IceProxy::BomberLoutreInterface::GameUserInterface::__newInstance() const
{
    return new GameUserInterface;
}

::std::string
IceProxy::BomberLoutreInterface::GameInterface::getName(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__GameInterface__getName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            return __del->getName(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_getName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__GameInterface__getName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__getName_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__getName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::BomberLoutreInterface::GameInterface::end_getName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__GameInterface__getName_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::BomberLoutreInterface::GameInterface::getState(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__GameInterface__getState_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            return __del->getState(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_getState(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__GameInterface__getState_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__getState_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__getState_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::BomberLoutreInterface::GameInterface::end_getState(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__GameInterface__getState_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::BomberLoutreInterface::GameInterface::getRoundCount(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__GameInterface__getRoundCount_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            return __del->getRoundCount(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_getRoundCount(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__GameInterface__getRoundCount_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__getRoundCount_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__getRoundCount_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::BomberLoutreInterface::GameInterface::end_getRoundCount(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__GameInterface__getRoundCount_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::BomberLoutreInterface::GameInterface::setName(const ::std::string& newname, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->setName(newname, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_setName(const ::std::string& newname, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__setName_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__setName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(newname);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_setName(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__setName_name);
}

void
IceProxy::BomberLoutreInterface::GameInterface::setState(::Ice::Int newstate, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->setState(newstate, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_setState(::Ice::Int newstate, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__setState_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__setState_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(newstate);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_setState(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__setState_name);
}

void
IceProxy::BomberLoutreInterface::GameInterface::setRoundCount(::Ice::Int newcount, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->setRoundCount(newcount, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_setRoundCount(::Ice::Int newcount, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__setRoundCount_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__setRoundCount_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(newcount);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_setRoundCount(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__setRoundCount_name);
}

void
IceProxy::BomberLoutreInterface::GameInterface::kickPlayer(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->kickPlayer(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_kickPlayer(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__kickPlayer_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__kickPlayer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_kickPlayer(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__kickPlayer_name);
}

void
IceProxy::BomberLoutreInterface::GameInterface::invitePlayer(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->invitePlayer(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_invitePlayer(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__invitePlayer_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__invitePlayer_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_invitePlayer(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__invitePlayer_name);
}

void
IceProxy::BomberLoutreInterface::GameInterface::addBot(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->addBot(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_addBot(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__addBot_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__addBot_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_addBot(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__addBot_name);
}

void
IceProxy::BomberLoutreInterface::GameInterface::removeBot(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->removeBot(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_removeBot(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__removeBot_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__removeBot_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_removeBot(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__removeBot_name);
}

::BomberLoutreInterface::MapNameList
IceProxy::BomberLoutreInterface::GameInterface::getMapList(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__GameInterface__getMapList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            return __del->getMapList(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_getMapList(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__GameInterface__getMapList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__getMapList_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__getMapList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::BomberLoutreInterface::MapNameList
IceProxy::BomberLoutreInterface::GameInterface::end_getMapList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__GameInterface__getMapList_name);
    ::BomberLoutreInterface::MapNameList __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::std::string
IceProxy::BomberLoutreInterface::GameInterface::createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__GameInterface__createMap_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            return __del->createMap(mode, mapSkin, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__GameInterface__createMap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__createMap_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__createMap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(mode);
        __os->write(mapSkin);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::BomberLoutreInterface::GameInterface::end_createMap(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__GameInterface__createMap_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::BomberLoutreInterface::GameInterface::startMap(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->startMap(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_startMap(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__startMap_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__startMap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_startMap(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__startMap_name);
}

void
IceProxy::BomberLoutreInterface::GameInterface::endMap(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            __del->endMap(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_endMap(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__endMap_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__endMap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameInterface::end_endMap(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameInterface__endMap_name);
}

bool
IceProxy::BomberLoutreInterface::GameInterface::removeGame(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__GameInterface__removeGame_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameInterface*>(__delBase.get());
            return __del->removeGame(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameInterface::begin_removeGame(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__GameInterface__removeGame_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameInterface__removeGame_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameInterface__removeGame_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::BomberLoutreInterface::GameInterface::end_removeGame(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__GameInterface__removeGame_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::BomberLoutreInterface::GameInterface::ice_staticId()
{
    return ::BomberLoutreInterface::GameInterface::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::BomberLoutreInterface::GameInterface::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::BomberLoutreInterface::GameInterface);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::BomberLoutreInterface::GameInterface::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::BomberLoutreInterface::GameInterface);
}

::IceProxy::Ice::Object*
IceProxy::BomberLoutreInterface::GameInterface::__newInstance() const
{
    return new GameInterface;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::newUserInRoom(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameWaitRoom*>(__delBase.get());
            __del->newUserInRoom(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameWaitRoom::begin_newUserInRoom(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameWaitRoom__newUserInRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameWaitRoom__newUserInRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::end_newUserInRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameWaitRoom__newUserInRoom_name);
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::userLeftRoom(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameWaitRoom*>(__delBase.get());
            __del->userLeftRoom(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameWaitRoom::begin_userLeftRoom(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameWaitRoom__userLeftRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameWaitRoom__userLeftRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::end_userLeftRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameWaitRoom__userLeftRoom_name);
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::allUsersReady(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameWaitRoom*>(__delBase.get());
            __del->allUsersReady(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameWaitRoom::begin_allUsersReady(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameWaitRoom__allUsersReady_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameWaitRoom__allUsersReady_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::end_allUsersReady(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameWaitRoom__allUsersReady_name);
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::userReady(const ::std::string& username, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameWaitRoom*>(__delBase.get());
            __del->userReady(username, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameWaitRoom::begin_userReady(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameWaitRoom__userReady_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameWaitRoom__userReady_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(username);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::end_userReady(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameWaitRoom__userReady_name);
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::gameDataUpdated(const ::BomberLoutreInterface::GameData& g, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameWaitRoom*>(__delBase.get());
            __del->gameDataUpdated(g, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameWaitRoom::begin_gameDataUpdated(const ::BomberLoutreInterface::GameData& g, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameWaitRoom__gameDataUpdated_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameWaitRoom__gameDataUpdated_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        g.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::end_gameDataUpdated(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameWaitRoom__gameDataUpdated_name);
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::newMapDefined(const ::std::string& map, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameWaitRoom*>(__delBase.get());
            __del->newMapDefined(map, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameWaitRoom::begin_newMapDefined(const ::std::string& map, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameWaitRoom__newMapDefined_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameWaitRoom__newMapDefined_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(map);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::end_newMapDefined(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameWaitRoom__newMapDefined_name);
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::gameStart(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameWaitRoom*>(__delBase.get());
            __del->gameStart(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameWaitRoom::begin_gameStart(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameWaitRoom__gameStart_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameWaitRoom__gameStart_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::end_gameStart(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameWaitRoom__gameStart_name);
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::gameEnd(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::GameWaitRoom* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::GameWaitRoom*>(__delBase.get());
            __del->gameEnd(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::GameWaitRoom::begin_gameEnd(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__GameWaitRoom__gameEnd_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__GameWaitRoom__gameEnd_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::GameWaitRoom::end_gameEnd(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__GameWaitRoom__gameEnd_name);
}

const ::std::string&
IceProxy::BomberLoutreInterface::GameWaitRoom::ice_staticId()
{
    return ::BomberLoutreInterface::GameWaitRoom::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::BomberLoutreInterface::GameWaitRoom::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::BomberLoutreInterface::GameWaitRoom);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::BomberLoutreInterface::GameWaitRoom::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::BomberLoutreInterface::GameWaitRoom);
}

::IceProxy::Ice::Object*
IceProxy::BomberLoutreInterface::GameWaitRoom::__newInstance() const
{
    return new GameWaitRoom;
}

::std::string
IceProxy::BomberLoutreInterface::MapInterface::getId(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__MapInterface__getId_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapInterface*>(__delBase.get());
            return __del->getId(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapInterface::begin_getId(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__MapInterface__getId_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapInterface__getId_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapInterface__getId_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::BomberLoutreInterface::MapInterface::end_getId(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__MapInterface__getId_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::BomberLoutreInterface::MapInterface::getWidth(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__MapInterface__getWidth_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapInterface*>(__delBase.get());
            return __del->getWidth(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapInterface::begin_getWidth(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__MapInterface__getWidth_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapInterface__getWidth_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapInterface__getWidth_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::BomberLoutreInterface::MapInterface::end_getWidth(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__MapInterface__getWidth_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::Ice::Int
IceProxy::BomberLoutreInterface::MapInterface::getHeight(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__MapInterface__getHeight_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapInterface*>(__delBase.get());
            return __del->getHeight(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapInterface::begin_getHeight(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__MapInterface__getHeight_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapInterface__getHeight_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapInterface__getHeight_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::BomberLoutreInterface::MapInterface::end_getHeight(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__MapInterface__getHeight_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::BomberLoutreInterface::MapInterface::moveUp(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapInterface*>(__delBase.get());
            __del->moveUp(p, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapInterface::begin_moveUp(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapInterface__moveUp_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapInterface__moveUp_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapInterface::end_moveUp(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapInterface__moveUp_name);
}

void
IceProxy::BomberLoutreInterface::MapInterface::moveDown(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapInterface*>(__delBase.get());
            __del->moveDown(p, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapInterface::begin_moveDown(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapInterface__moveDown_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapInterface__moveDown_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapInterface::end_moveDown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapInterface__moveDown_name);
}

void
IceProxy::BomberLoutreInterface::MapInterface::moveLeft(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapInterface*>(__delBase.get());
            __del->moveLeft(p, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapInterface::begin_moveLeft(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapInterface__moveLeft_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapInterface__moveLeft_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapInterface::end_moveLeft(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapInterface__moveLeft_name);
}

void
IceProxy::BomberLoutreInterface::MapInterface::moveRight(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapInterface*>(__delBase.get());
            __del->moveRight(p, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapInterface::begin_moveRight(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapInterface__moveRight_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapInterface__moveRight_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapInterface::end_moveRight(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapInterface__moveRight_name);
}

void
IceProxy::BomberLoutreInterface::MapInterface::dropBomb(const ::BomberLoutreInterface::Player& p, const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapInterface*>(__delBase.get());
            __del->dropBomb(p, b, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapInterface::begin_dropBomb(const ::BomberLoutreInterface::Player& p, const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapInterface__dropBomb_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapInterface__dropBomb_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        b.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapInterface::end_dropBomb(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapInterface__dropBomb_name);
}

const ::std::string&
IceProxy::BomberLoutreInterface::MapInterface::ice_staticId()
{
    return ::BomberLoutreInterface::MapInterface::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::BomberLoutreInterface::MapInterface::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::BomberLoutreInterface::MapInterface);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::BomberLoutreInterface::MapInterface::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::BomberLoutreInterface::MapInterface);
}

::IceProxy::Ice::Object*
IceProxy::BomberLoutreInterface::MapInterface::__newInstance() const
{
    return new MapInterface;
}

void
IceProxy::BomberLoutreInterface::MapObserver::refreshMapItems(const ::BomberLoutreInterface::MapItems& mi, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapObserver* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapObserver*>(__delBase.get());
            __del->refreshMapItems(mi, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapObserver::begin_refreshMapItems(const ::BomberLoutreInterface::MapItems& mi, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapObserver__refreshMapItems_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapObserver__refreshMapItems_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(mi.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::BomberLoutreInterface::__writeMapItems(__os, &mi[0], &mi[0] + mi.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapObserver::end_refreshMapItems(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapObserver__refreshMapItems_name);
}

void
IceProxy::BomberLoutreInterface::MapObserver::refreshPlayers(const ::BomberLoutreInterface::PlayerList& p, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapObserver* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapObserver*>(__delBase.get());
            __del->refreshPlayers(p, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapObserver::begin_refreshPlayers(const ::BomberLoutreInterface::PlayerList& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapObserver__refreshPlayers_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapObserver__refreshPlayers_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(p.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::BomberLoutreInterface::__writePlayerList(__os, &p[0], &p[0] + p.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapObserver::end_refreshPlayers(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapObserver__refreshPlayers_name);
}

void
IceProxy::BomberLoutreInterface::MapObserver::bombHasBeenPlanted(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapObserver* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapObserver*>(__delBase.get());
            __del->bombHasBeenPlanted(b, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapObserver::begin_bombHasBeenPlanted(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapObserver__bombHasBeenPlanted_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapObserver__bombHasBeenPlanted_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        b.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapObserver::end_bombHasBeenPlanted(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapObserver__bombHasBeenPlanted_name);
}

void
IceProxy::BomberLoutreInterface::MapObserver::bombExploded(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapObserver* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapObserver*>(__delBase.get());
            __del->bombExploded(b, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapObserver::begin_bombExploded(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapObserver__bombExploded_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapObserver__bombExploded_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        b.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapObserver::end_bombExploded(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapObserver__bombExploded_name);
}

void
IceProxy::BomberLoutreInterface::MapObserver::bombKicked(const ::BomberLoutreInterface::Bomb& b, const ::BomberLoutreInterface::Point& dest, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapObserver* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapObserver*>(__delBase.get());
            __del->bombKicked(b, dest, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapObserver::begin_bombKicked(const ::BomberLoutreInterface::Bomb& b, const ::BomberLoutreInterface::Point& dest, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapObserver__bombKicked_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapObserver__bombKicked_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        b.__write(__os);
        dest.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapObserver::end_bombKicked(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapObserver__bombKicked_name);
}

void
IceProxy::BomberLoutreInterface::MapObserver::bonusesDropped(const ::BomberLoutreInterface::Bonuses& b, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapObserver* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapObserver*>(__delBase.get());
            __del->bonusesDropped(b, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapObserver::begin_bonusesDropped(const ::BomberLoutreInterface::Bonuses& b, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapObserver__bonusesDropped_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapObserver__bonusesDropped_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(b.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::BomberLoutreInterface::__writeBonuses(__os, &b[0], &b[0] + b.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapObserver::end_bonusesDropped(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapObserver__bonusesDropped_name);
}

void
IceProxy::BomberLoutreInterface::MapObserver::playerDied(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::MapObserver* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::MapObserver*>(__delBase.get());
            __del->playerDied(p, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::MapObserver::begin_playerDied(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__MapObserver__playerDied_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__MapObserver__playerDied_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        p.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::BomberLoutreInterface::MapObserver::end_playerDied(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BomberLoutreInterface__MapObserver__playerDied_name);
}

const ::std::string&
IceProxy::BomberLoutreInterface::MapObserver::ice_staticId()
{
    return ::BomberLoutreInterface::MapObserver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::BomberLoutreInterface::MapObserver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::BomberLoutreInterface::MapObserver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::BomberLoutreInterface::MapObserver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::BomberLoutreInterface::MapObserver);
}

::IceProxy::Ice::Object*
IceProxy::BomberLoutreInterface::MapObserver::__newInstance() const
{
    return new MapObserver;
}

::BomberLoutreInterface::UserData
IceProxy::BomberLoutreInterface::ServerInterface::connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__ServerInterface__connect_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::ServerInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::ServerInterface*>(__delBase.get());
            return __del->connect(login, password, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::ServerInterface::begin_connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__ServerInterface__connect_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__ServerInterface__connect_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__ServerInterface__connect_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(login);
        __os->write(password);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::BomberLoutreInterface::UserData
IceProxy::BomberLoutreInterface::ServerInterface::end_connect(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__ServerInterface__connect_name);
    ::BomberLoutreInterface::UserData __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::BomberLoutreInterface::BadLoginException&)
        {
            throw;
        }
        catch(const ::BomberLoutreInterface::BadPasswordException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

::BomberLoutreInterface::UserData
IceProxy::BomberLoutreInterface::ServerInterface::createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__ServerInterface__createUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::ServerInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::ServerInterface*>(__delBase.get());
            return __del->createUser(login, password, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::ServerInterface::begin_createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__ServerInterface__createUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__ServerInterface__createUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__ServerInterface__createUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(login);
        __os->write(password);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::BomberLoutreInterface::UserData
IceProxy::BomberLoutreInterface::ServerInterface::end_createUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__ServerInterface__createUser_name);
    ::BomberLoutreInterface::UserData __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::BomberLoutreInterface::UserAlreadyExistsException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

bool
IceProxy::BomberLoutreInterface::ServerInterface::deleteUser(const ::std::string& login, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__ServerInterface__deleteUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::ServerInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::ServerInterface*>(__delBase.get());
            return __del->deleteUser(login, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::ServerInterface::begin_deleteUser(const ::std::string& login, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__ServerInterface__deleteUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__ServerInterface__deleteUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__ServerInterface__deleteUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(login);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::BomberLoutreInterface::ServerInterface::end_deleteUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__ServerInterface__deleteUser_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

::BomberLoutreInterface::GameInterfacePrx
IceProxy::BomberLoutreInterface::ServerInterface::addGame(const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__ServerInterface__addGame_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::ServerInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::ServerInterface*>(__delBase.get());
            return __del->addGame(name, user, room, mo, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::ServerInterface::begin_addGame(const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__ServerInterface__addGame_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__ServerInterface__addGame_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__ServerInterface__addGame_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(name);
        user.__write(__os);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(room.get())));
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mo.get())));
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::BomberLoutreInterface::GameInterfacePrx
IceProxy::BomberLoutreInterface::ServerInterface::end_addGame(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__ServerInterface__addGame_name);
    ::BomberLoutreInterface::GameInterfacePrx __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::BomberLoutreInterface::__read(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::BomberLoutreInterface::Map
IceProxy::BomberLoutreInterface::ServerInterface::joinGame(const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__ServerInterface__joinGame_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::ServerInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::ServerInterface*>(__delBase.get());
            return __del->joinGame(name, user, room, mo, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::ServerInterface::begin_joinGame(const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__ServerInterface__joinGame_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__ServerInterface__joinGame_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__ServerInterface__joinGame_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(name);
        user.__write(__os);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(room.get())));
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mo.get())));
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::BomberLoutreInterface::Map
IceProxy::BomberLoutreInterface::ServerInterface::end_joinGame(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__ServerInterface__joinGame_name);
    ::BomberLoutreInterface::Map __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __ret.__read(__is);
    __is->endReadEncaps();
    return __ret;
}

::BomberLoutreInterface::GameDataList
IceProxy::BomberLoutreInterface::ServerInterface::getGameList(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__ServerInterface__getGameList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::ServerInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::ServerInterface*>(__delBase.get());
            return __del->getGameList(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::ServerInterface::begin_getGameList(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__ServerInterface__getGameList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__ServerInterface__getGameList_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__ServerInterface__getGameList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::BomberLoutreInterface::GameDataList
IceProxy::BomberLoutreInterface::ServerInterface::end_getGameList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__ServerInterface__getGameList_name);
    ::BomberLoutreInterface::GameDataList __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::BomberLoutreInterface::__readGameDataList(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::BomberLoutreInterface::UserDataList
IceProxy::BomberLoutreInterface::ServerInterface::getUserList(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__BomberLoutreInterface__ServerInterface__getUserList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::BomberLoutreInterface::ServerInterface* __del = dynamic_cast< ::IceDelegate::BomberLoutreInterface::ServerInterface*>(__delBase.get());
            return __del->getUserList(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BomberLoutreInterface::ServerInterface::begin_getUserList(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BomberLoutreInterface__ServerInterface__getUserList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BomberLoutreInterface__ServerInterface__getUserList_name, __del, __cookie);
    try
    {
        __result->__prepare(__BomberLoutreInterface__ServerInterface__getUserList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::BomberLoutreInterface::UserDataList
IceProxy::BomberLoutreInterface::ServerInterface::end_getUserList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BomberLoutreInterface__ServerInterface__getUserList_name);
    ::BomberLoutreInterface::UserDataList __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::BomberLoutreInterface::__readUserDataList(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

const ::std::string&
IceProxy::BomberLoutreInterface::ServerInterface::ice_staticId()
{
    return ::BomberLoutreInterface::ServerInterface::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::BomberLoutreInterface::ServerInterface::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::BomberLoutreInterface::ServerInterface);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::BomberLoutreInterface::ServerInterface::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::BomberLoutreInterface::ServerInterface);
}

::IceProxy::Ice::Object*
IceProxy::BomberLoutreInterface::ServerInterface::__newInstance() const
{
    return new ServerInterface;
}

::std::string
IceDelegateM::BomberLoutreInterface::GameUserInterface::getCreatorName(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameUserInterface__getCreatorName_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::BomberLoutreInterface::GameUserInterface::userReady(const ::BomberLoutreInterface::UserData& u, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameUserInterface__userReady_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        u.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameUserInterface::leaveGame(const ::BomberLoutreInterface::UserData& u, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameUserInterface__leaveGame_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        u.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::std::string
IceDelegateM::BomberLoutreInterface::GameInterface::getName(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__getName_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::BomberLoutreInterface::GameInterface::getState(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__getState_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::BomberLoutreInterface::GameInterface::getRoundCount(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__getRoundCount_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::setName(const ::std::string& newname, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__setName_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(newname);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::setState(::Ice::Int newstate, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__setState_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(newstate);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::setRoundCount(::Ice::Int newcount, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__setRoundCount_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(newcount);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::kickPlayer(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__kickPlayer_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::invitePlayer(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__invitePlayer_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::addBot(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__addBot_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::removeBot(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__removeBot_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::BomberLoutreInterface::MapNameList
IceDelegateM::BomberLoutreInterface::GameInterface::getMapList(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__getMapList_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::BomberLoutreInterface::MapNameList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::BomberLoutreInterface::GameInterface::createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__createMap_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(mode);
        __os->write(mapSkin);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::startMap(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__startMap_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameInterface::endMap(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__endMap_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::BomberLoutreInterface::GameInterface::removeGame(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameInterface__removeGame_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::BomberLoutreInterface::GameWaitRoom::newUserInRoom(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameWaitRoom__newUserInRoom_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameWaitRoom::userLeftRoom(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameWaitRoom__userLeftRoom_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameWaitRoom::allUsersReady(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameWaitRoom__allUsersReady_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameWaitRoom::userReady(const ::std::string& username, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameWaitRoom__userReady_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(username);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameWaitRoom::gameDataUpdated(const ::BomberLoutreInterface::GameData& g, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameWaitRoom__gameDataUpdated_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        g.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameWaitRoom::newMapDefined(const ::std::string& map, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameWaitRoom__newMapDefined_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(map);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameWaitRoom::gameStart(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameWaitRoom__gameStart_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::GameWaitRoom::gameEnd(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__GameWaitRoom__gameEnd_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::std::string
IceDelegateM::BomberLoutreInterface::MapInterface::getId(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapInterface__getId_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::BomberLoutreInterface::MapInterface::getWidth(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapInterface__getWidth_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::BomberLoutreInterface::MapInterface::getHeight(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapInterface__getHeight_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::BomberLoutreInterface::MapInterface::moveUp(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapInterface__moveUp_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapInterface::moveDown(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapInterface__moveDown_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapInterface::moveLeft(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapInterface__moveLeft_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapInterface::moveRight(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapInterface__moveRight_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapInterface::dropBomb(const ::BomberLoutreInterface::Player& p, const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapInterface__dropBomb_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
        b.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapObserver::refreshMapItems(const ::BomberLoutreInterface::MapItems& mi, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapObserver__refreshMapItems_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(mi.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::BomberLoutreInterface::__writeMapItems(__os, &mi[0], &mi[0] + mi.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapObserver::refreshPlayers(const ::BomberLoutreInterface::PlayerList& p, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapObserver__refreshPlayers_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(p.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::BomberLoutreInterface::__writePlayerList(__os, &p[0], &p[0] + p.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapObserver::bombHasBeenPlanted(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapObserver__bombHasBeenPlanted_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        b.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapObserver::bombExploded(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapObserver__bombExploded_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        b.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapObserver::bombKicked(const ::BomberLoutreInterface::Bomb& b, const ::BomberLoutreInterface::Point& dest, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapObserver__bombKicked_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        b.__write(__os);
        dest.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapObserver::bonusesDropped(const ::BomberLoutreInterface::Bonuses& b, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapObserver__bonusesDropped_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(b.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::BomberLoutreInterface::__writeBonuses(__os, &b[0], &b[0] + b.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::BomberLoutreInterface::MapObserver::playerDied(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__MapObserver__playerDied_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        p.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::BomberLoutreInterface::UserData
IceDelegateM::BomberLoutreInterface::ServerInterface::connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__ServerInterface__connect_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(login);
        __os->write(password);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::BomberLoutreInterface::UserData __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::BomberLoutreInterface::BadLoginException&)
            {
                throw;
            }
            catch(const ::BomberLoutreInterface::BadPasswordException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::BomberLoutreInterface::UserData
IceDelegateM::BomberLoutreInterface::ServerInterface::createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__ServerInterface__createUser_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(login);
        __os->write(password);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::BomberLoutreInterface::UserData __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::BomberLoutreInterface::UserAlreadyExistsException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

bool
IceDelegateM::BomberLoutreInterface::ServerInterface::deleteUser(const ::std::string& login, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__ServerInterface__deleteUser_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(login);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::BomberLoutreInterface::GameInterfacePrx
IceDelegateM::BomberLoutreInterface::ServerInterface::addGame(const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__ServerInterface__addGame_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(name);
        user.__write(__os);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(room.get())));
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mo.get())));
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::BomberLoutreInterface::GameInterfacePrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::BomberLoutreInterface::__read(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::BomberLoutreInterface::Map
IceDelegateM::BomberLoutreInterface::ServerInterface::joinGame(const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__ServerInterface__joinGame_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(name);
        user.__write(__os);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(room.get())));
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(mo.get())));
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::BomberLoutreInterface::Map __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __ret.__read(__is);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::BomberLoutreInterface::GameDataList
IceDelegateM::BomberLoutreInterface::ServerInterface::getGameList(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__ServerInterface__getGameList_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::BomberLoutreInterface::GameDataList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::BomberLoutreInterface::__readGameDataList(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::BomberLoutreInterface::UserDataList
IceDelegateM::BomberLoutreInterface::ServerInterface::getUserList(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __BomberLoutreInterface__ServerInterface__getUserList_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::BomberLoutreInterface::UserDataList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::BomberLoutreInterface::__readUserDataList(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateD::BomberLoutreInterface::GameUserInterface::getCreatorName(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameUserInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameUserInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getCreatorName(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameUserInterface__getCreatorName_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::BomberLoutreInterface::GameUserInterface::userReady(const ::BomberLoutreInterface::UserData& u, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::UserData& u, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_u(u)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameUserInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameUserInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userReady(_m_u, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::UserData& _m_u;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameUserInterface__userReady_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(u, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameUserInterface::leaveGame(const ::BomberLoutreInterface::UserData& u, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::UserData& u, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_u(u)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameUserInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameUserInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->leaveGame(_m_u, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::UserData& _m_u;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameUserInterface__leaveGame_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(u, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::BomberLoutreInterface::GameInterface::getName(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getName(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__getName_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::BomberLoutreInterface::GameInterface::getState(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getState(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__getState_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::BomberLoutreInterface::GameInterface::getRoundCount(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getRoundCount(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__getRoundCount_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::setName(const ::std::string& newname, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& newname, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_newname(newname)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setName(_m_newname, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_newname;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__setName_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(newname, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::setState(::Ice::Int newstate, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int newstate, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_newstate(newstate)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setState(_m_newstate, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_newstate;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__setState_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(newstate, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::setRoundCount(::Ice::Int newcount, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int newcount, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_newcount(newcount)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setRoundCount(_m_newcount, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_newcount;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__setRoundCount_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(newcount, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::kickPlayer(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->kickPlayer(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__kickPlayer_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::invitePlayer(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->invitePlayer(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__invitePlayer_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::addBot(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->addBot(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__addBot_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::removeBot(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->removeBot(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__removeBot_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::BomberLoutreInterface::MapNameList
IceDelegateD::BomberLoutreInterface::GameInterface::getMapList(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::BomberLoutreInterface::MapNameList& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getMapList(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::BomberLoutreInterface::MapNameList& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__getMapList_name, ::Ice::Normal, __context);
    ::BomberLoutreInterface::MapNameList __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::BomberLoutreInterface::GameInterface::createMap(const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::std::string& mode, const ::std::string& mapSkin, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_mode(mode),
            _m_mapSkin(mapSkin)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->createMap(_m_mode, _m_mapSkin, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
        const ::std::string& _m_mode;
        const ::std::string& _m_mapSkin;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__createMap_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, mode, mapSkin, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::startMap(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->startMap(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__startMap_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameInterface::endMap(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->endMap(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__endMap_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::BomberLoutreInterface::GameInterface::removeGame(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameInterface* servant = dynamic_cast< ::BomberLoutreInterface::GameInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->removeGame(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameInterface__removeGame_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::BomberLoutreInterface::GameWaitRoom::newUserInRoom(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameWaitRoom* servant = dynamic_cast< ::BomberLoutreInterface::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->newUserInRoom(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameWaitRoom__newUserInRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameWaitRoom::userLeftRoom(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameWaitRoom* servant = dynamic_cast< ::BomberLoutreInterface::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userLeftRoom(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameWaitRoom__userLeftRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameWaitRoom::allUsersReady(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameWaitRoom* servant = dynamic_cast< ::BomberLoutreInterface::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->allUsersReady(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameWaitRoom__allUsersReady_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameWaitRoom::userReady(const ::std::string& username, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameWaitRoom* servant = dynamic_cast< ::BomberLoutreInterface::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->userReady(_m_username, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameWaitRoom__userReady_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameWaitRoom::gameDataUpdated(const ::BomberLoutreInterface::GameData& g, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::GameData& g, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_g(g)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameWaitRoom* servant = dynamic_cast< ::BomberLoutreInterface::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->gameDataUpdated(_m_g, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::GameData& _m_g;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameWaitRoom__gameDataUpdated_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(g, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameWaitRoom::newMapDefined(const ::std::string& map, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& map, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_map(map)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameWaitRoom* servant = dynamic_cast< ::BomberLoutreInterface::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->newMapDefined(_m_map, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_map;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameWaitRoom__newMapDefined_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(map, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameWaitRoom::gameStart(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameWaitRoom* servant = dynamic_cast< ::BomberLoutreInterface::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->gameStart(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameWaitRoom__gameStart_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::GameWaitRoom::gameEnd(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::GameWaitRoom* servant = dynamic_cast< ::BomberLoutreInterface::GameWaitRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->gameEnd(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__GameWaitRoom__gameEnd_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::BomberLoutreInterface::MapInterface::getId(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapInterface* servant = dynamic_cast< ::BomberLoutreInterface::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getId(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapInterface__getId_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::BomberLoutreInterface::MapInterface::getWidth(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapInterface* servant = dynamic_cast< ::BomberLoutreInterface::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getWidth(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapInterface__getWidth_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::BomberLoutreInterface::MapInterface::getHeight(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapInterface* servant = dynamic_cast< ::BomberLoutreInterface::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getHeight(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapInterface__getHeight_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::BomberLoutreInterface::MapInterface::moveUp(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Player& p, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapInterface* servant = dynamic_cast< ::BomberLoutreInterface::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->moveUp(_m_p, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Player& _m_p;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapInterface__moveUp_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapInterface::moveDown(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Player& p, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapInterface* servant = dynamic_cast< ::BomberLoutreInterface::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->moveDown(_m_p, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Player& _m_p;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapInterface__moveDown_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapInterface::moveLeft(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Player& p, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapInterface* servant = dynamic_cast< ::BomberLoutreInterface::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->moveLeft(_m_p, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Player& _m_p;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapInterface__moveLeft_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapInterface::moveRight(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Player& p, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapInterface* servant = dynamic_cast< ::BomberLoutreInterface::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->moveRight(_m_p, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Player& _m_p;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapInterface__moveRight_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapInterface::dropBomb(const ::BomberLoutreInterface::Player& p, const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Player& p, const ::BomberLoutreInterface::Bomb& b, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p),
            _m_b(b)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapInterface* servant = dynamic_cast< ::BomberLoutreInterface::MapInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->dropBomb(_m_p, _m_b, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Player& _m_p;
        const ::BomberLoutreInterface::Bomb& _m_b;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapInterface__dropBomb_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, b, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapObserver::refreshMapItems(const ::BomberLoutreInterface::MapItems& mi, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::MapItems& mi, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_mi(mi)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapObserver* servant = dynamic_cast< ::BomberLoutreInterface::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->refreshMapItems(_m_mi, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::MapItems& _m_mi;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapObserver__refreshMapItems_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(mi, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapObserver::refreshPlayers(const ::BomberLoutreInterface::PlayerList& p, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::PlayerList& p, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapObserver* servant = dynamic_cast< ::BomberLoutreInterface::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->refreshPlayers(_m_p, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::PlayerList& _m_p;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapObserver__refreshPlayers_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapObserver::bombHasBeenPlanted(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_b(b)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapObserver* servant = dynamic_cast< ::BomberLoutreInterface::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->bombHasBeenPlanted(_m_b, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Bomb& _m_b;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapObserver__bombHasBeenPlanted_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(b, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapObserver::bombExploded(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Bomb& b, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_b(b)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapObserver* servant = dynamic_cast< ::BomberLoutreInterface::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->bombExploded(_m_b, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Bomb& _m_b;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapObserver__bombExploded_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(b, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapObserver::bombKicked(const ::BomberLoutreInterface::Bomb& b, const ::BomberLoutreInterface::Point& dest, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Bomb& b, const ::BomberLoutreInterface::Point& dest, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_b(b),
            _m_dest(dest)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapObserver* servant = dynamic_cast< ::BomberLoutreInterface::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->bombKicked(_m_b, _m_dest, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Bomb& _m_b;
        const ::BomberLoutreInterface::Point& _m_dest;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapObserver__bombKicked_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(b, dest, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapObserver::bonusesDropped(const ::BomberLoutreInterface::Bonuses& b, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Bonuses& b, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_b(b)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapObserver* servant = dynamic_cast< ::BomberLoutreInterface::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->bonusesDropped(_m_b, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Bonuses& _m_b;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapObserver__bonusesDropped_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(b, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::BomberLoutreInterface::MapObserver::playerDied(const ::BomberLoutreInterface::Player& p, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::BomberLoutreInterface::Player& p, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_p(p)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::MapObserver* servant = dynamic_cast< ::BomberLoutreInterface::MapObserver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->playerDied(_m_p, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::BomberLoutreInterface::Player& _m_p;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__MapObserver__playerDied_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(p, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::BomberLoutreInterface::UserData
IceDelegateD::BomberLoutreInterface::ServerInterface::connect(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::BomberLoutreInterface::UserData& __result, const ::std::string& login, const ::std::string& password, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_login(login),
            _m_password(password)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::ServerInterface* servant = dynamic_cast< ::BomberLoutreInterface::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->connect(_m_login, _m_password, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::BomberLoutreInterface::UserData& _result;
        const ::std::string& _m_login;
        const ::std::string& _m_password;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__ServerInterface__connect_name, ::Ice::Normal, __context);
    ::BomberLoutreInterface::UserData __result;
    try
    {
        _DirectI __direct(__result, login, password, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::BomberLoutreInterface::BadLoginException&)
    {
        throw;
    }
    catch(const ::BomberLoutreInterface::BadPasswordException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::BomberLoutreInterface::UserData
IceDelegateD::BomberLoutreInterface::ServerInterface::createUser(const ::std::string& login, const ::std::string& password, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::BomberLoutreInterface::UserData& __result, const ::std::string& login, const ::std::string& password, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_login(login),
            _m_password(password)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::ServerInterface* servant = dynamic_cast< ::BomberLoutreInterface::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->createUser(_m_login, _m_password, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::BomberLoutreInterface::UserData& _result;
        const ::std::string& _m_login;
        const ::std::string& _m_password;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__ServerInterface__createUser_name, ::Ice::Normal, __context);
    ::BomberLoutreInterface::UserData __result;
    try
    {
        _DirectI __direct(__result, login, password, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::BomberLoutreInterface::UserAlreadyExistsException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

bool
IceDelegateD::BomberLoutreInterface::ServerInterface::deleteUser(const ::std::string& login, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::std::string& login, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_login(login)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::ServerInterface* servant = dynamic_cast< ::BomberLoutreInterface::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->deleteUser(_m_login, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::std::string& _m_login;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__ServerInterface__deleteUser_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, login, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::BomberLoutreInterface::GameInterfacePrx
IceDelegateD::BomberLoutreInterface::ServerInterface::addGame(const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::BomberLoutreInterface::GameInterfacePrx& __result, const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_name(name),
            _m_user(user),
            _m_room(room),
            _m_mo(mo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::ServerInterface* servant = dynamic_cast< ::BomberLoutreInterface::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->addGame(_m_name, _m_user, _m_room, _m_mo, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::BomberLoutreInterface::GameInterfacePrx& _result;
        const ::std::string& _m_name;
        const ::BomberLoutreInterface::UserData& _m_user;
        const ::BomberLoutreInterface::GameWaitRoomPrx& _m_room;
        const ::BomberLoutreInterface::MapObserverPrx& _m_mo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__ServerInterface__addGame_name, ::Ice::Normal, __context);
    ::BomberLoutreInterface::GameInterfacePrx __result;
    try
    {
        _DirectI __direct(__result, name, user, room, mo, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::BomberLoutreInterface::Map
IceDelegateD::BomberLoutreInterface::ServerInterface::joinGame(const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::BomberLoutreInterface::Map& __result, const ::std::string& name, const ::BomberLoutreInterface::UserData& user, const ::BomberLoutreInterface::GameWaitRoomPrx& room, const ::BomberLoutreInterface::MapObserverPrx& mo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_name(name),
            _m_user(user),
            _m_room(room),
            _m_mo(mo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::ServerInterface* servant = dynamic_cast< ::BomberLoutreInterface::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->joinGame(_m_name, _m_user, _m_room, _m_mo, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::BomberLoutreInterface::Map& _result;
        const ::std::string& _m_name;
        const ::BomberLoutreInterface::UserData& _m_user;
        const ::BomberLoutreInterface::GameWaitRoomPrx& _m_room;
        const ::BomberLoutreInterface::MapObserverPrx& _m_mo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__ServerInterface__joinGame_name, ::Ice::Normal, __context);
    ::BomberLoutreInterface::Map __result;
    try
    {
        _DirectI __direct(__result, name, user, room, mo, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::BomberLoutreInterface::GameDataList
IceDelegateD::BomberLoutreInterface::ServerInterface::getGameList(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::BomberLoutreInterface::GameDataList& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::ServerInterface* servant = dynamic_cast< ::BomberLoutreInterface::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getGameList(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::BomberLoutreInterface::GameDataList& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__ServerInterface__getGameList_name, ::Ice::Normal, __context);
    ::BomberLoutreInterface::GameDataList __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::BomberLoutreInterface::UserDataList
IceDelegateD::BomberLoutreInterface::ServerInterface::getUserList(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::BomberLoutreInterface::UserDataList& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::BomberLoutreInterface::ServerInterface* servant = dynamic_cast< ::BomberLoutreInterface::ServerInterface*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getUserList(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::BomberLoutreInterface::UserDataList& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __BomberLoutreInterface__ServerInterface__getUserList_name, ::Ice::Normal, __context);
    ::BomberLoutreInterface::UserDataList __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::ObjectPtr
BomberLoutreInterface::GameUserInterface::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __BomberLoutreInterface__GameUserInterface_ids[2] =
{
    "::BomberLoutreInterface::GameUserInterface",
    "::Ice::Object"
};

bool
BomberLoutreInterface::GameUserInterface::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BomberLoutreInterface__GameUserInterface_ids, __BomberLoutreInterface__GameUserInterface_ids + 2, _s);
}

::std::vector< ::std::string>
BomberLoutreInterface::GameUserInterface::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BomberLoutreInterface__GameUserInterface_ids[0], &__BomberLoutreInterface__GameUserInterface_ids[2]);
}

const ::std::string&
BomberLoutreInterface::GameUserInterface::ice_id(const ::Ice::Current&) const
{
    return __BomberLoutreInterface__GameUserInterface_ids[0];
}

const ::std::string&
BomberLoutreInterface::GameUserInterface::ice_staticId()
{
    return __BomberLoutreInterface__GameUserInterface_ids[0];
}

::Ice::DispatchStatus
BomberLoutreInterface::GameUserInterface::___getCreatorName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getCreatorName(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameUserInterface::___userReady(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::UserData u;
    u.__read(__is);
    __is->endReadEncaps();
    userReady(u, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameUserInterface::___leaveGame(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::UserData u;
    u.__read(__is);
    __is->endReadEncaps();
    leaveGame(u, __current);
    return ::Ice::DispatchOK;
}

static ::std::string __BomberLoutreInterface__GameUserInterface_all[] =
{
    "getCreatorName",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "leaveGame",
    "userReady"
};

::Ice::DispatchStatus
BomberLoutreInterface::GameUserInterface::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__BomberLoutreInterface__GameUserInterface_all, __BomberLoutreInterface__GameUserInterface_all + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BomberLoutreInterface__GameUserInterface_all)
    {
        case 0:
        {
            return ___getCreatorName(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___leaveGame(in, current);
        }
        case 6:
        {
            return ___userReady(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BomberLoutreInterface::GameUserInterface::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
BomberLoutreInterface::GameUserInterface::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::GameUserInterface::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::GameUserInterface was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::GameUserInterface::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::GameUserInterface was not generated with stream support";
    throw ex;
}
#endif

void 
BomberLoutreInterface::__patch__GameUserInterfacePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::BomberLoutreInterface::GameUserInterfacePtr* p = static_cast< ::BomberLoutreInterface::GameUserInterfacePtr*>(__addr);
    assert(p);
    *p = ::BomberLoutreInterface::GameUserInterfacePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::BomberLoutreInterface::GameUserInterface::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
BomberLoutreInterface::GameInterface::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __BomberLoutreInterface__GameInterface_ids[2] =
{
    "::BomberLoutreInterface::GameInterface",
    "::Ice::Object"
};

bool
BomberLoutreInterface::GameInterface::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BomberLoutreInterface__GameInterface_ids, __BomberLoutreInterface__GameInterface_ids + 2, _s);
}

::std::vector< ::std::string>
BomberLoutreInterface::GameInterface::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BomberLoutreInterface__GameInterface_ids[0], &__BomberLoutreInterface__GameInterface_ids[2]);
}

const ::std::string&
BomberLoutreInterface::GameInterface::ice_id(const ::Ice::Current&) const
{
    return __BomberLoutreInterface__GameInterface_ids[0];
}

const ::std::string&
BomberLoutreInterface::GameInterface::ice_staticId()
{
    return __BomberLoutreInterface__GameInterface_ids[0];
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___getName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getName(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___getState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getState(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___getRoundCount(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getRoundCount(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___setName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string newname;
    __is->read(newname);
    __is->endReadEncaps();
    setName(newname, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___setState(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int newstate;
    __is->read(newstate);
    __is->endReadEncaps();
    setState(newstate, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___setRoundCount(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::Int newcount;
    __is->read(newcount);
    __is->endReadEncaps();
    setRoundCount(newcount, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___kickPlayer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    kickPlayer(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___invitePlayer(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    invitePlayer(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___addBot(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    addBot(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___removeBot(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    removeBot(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___getMapList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::BomberLoutreInterface::MapNameList __ret = getMapList(__current);
    if(__ret.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        __os->write(&__ret[0], &__ret[0] + __ret.size());
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___createMap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string mode;
    ::std::string mapSkin;
    __is->read(mode);
    __is->read(mapSkin);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = createMap(mode, mapSkin, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___startMap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    startMap(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___endMap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    endMap(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::___removeGame(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = removeGame(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

static ::std::string __BomberLoutreInterface__GameInterface_all[] =
{
    "addBot",
    "createMap",
    "endMap",
    "getMapList",
    "getName",
    "getRoundCount",
    "getState",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "invitePlayer",
    "kickPlayer",
    "removeBot",
    "removeGame",
    "setName",
    "setRoundCount",
    "setState",
    "startMap"
};

::Ice::DispatchStatus
BomberLoutreInterface::GameInterface::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__BomberLoutreInterface__GameInterface_all, __BomberLoutreInterface__GameInterface_all + 19, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BomberLoutreInterface__GameInterface_all)
    {
        case 0:
        {
            return ___addBot(in, current);
        }
        case 1:
        {
            return ___createMap(in, current);
        }
        case 2:
        {
            return ___endMap(in, current);
        }
        case 3:
        {
            return ___getMapList(in, current);
        }
        case 4:
        {
            return ___getName(in, current);
        }
        case 5:
        {
            return ___getRoundCount(in, current);
        }
        case 6:
        {
            return ___getState(in, current);
        }
        case 7:
        {
            return ___ice_id(in, current);
        }
        case 8:
        {
            return ___ice_ids(in, current);
        }
        case 9:
        {
            return ___ice_isA(in, current);
        }
        case 10:
        {
            return ___ice_ping(in, current);
        }
        case 11:
        {
            return ___invitePlayer(in, current);
        }
        case 12:
        {
            return ___kickPlayer(in, current);
        }
        case 13:
        {
            return ___removeBot(in, current);
        }
        case 14:
        {
            return ___removeGame(in, current);
        }
        case 15:
        {
            return ___setName(in, current);
        }
        case 16:
        {
            return ___setRoundCount(in, current);
        }
        case 17:
        {
            return ___setState(in, current);
        }
        case 18:
        {
            return ___startMap(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BomberLoutreInterface::GameInterface::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
BomberLoutreInterface::GameInterface::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::GameInterface::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::GameInterface was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::GameInterface::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::GameInterface was not generated with stream support";
    throw ex;
}
#endif

void 
BomberLoutreInterface::__patch__GameInterfacePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::BomberLoutreInterface::GameInterfacePtr* p = static_cast< ::BomberLoutreInterface::GameInterfacePtr*>(__addr);
    assert(p);
    *p = ::BomberLoutreInterface::GameInterfacePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::BomberLoutreInterface::GameInterface::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
BomberLoutreInterface::GameWaitRoom::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __BomberLoutreInterface__GameWaitRoom_ids[2] =
{
    "::BomberLoutreInterface::GameWaitRoom",
    "::Ice::Object"
};

bool
BomberLoutreInterface::GameWaitRoom::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BomberLoutreInterface__GameWaitRoom_ids, __BomberLoutreInterface__GameWaitRoom_ids + 2, _s);
}

::std::vector< ::std::string>
BomberLoutreInterface::GameWaitRoom::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BomberLoutreInterface__GameWaitRoom_ids[0], &__BomberLoutreInterface__GameWaitRoom_ids[2]);
}

const ::std::string&
BomberLoutreInterface::GameWaitRoom::ice_id(const ::Ice::Current&) const
{
    return __BomberLoutreInterface__GameWaitRoom_ids[0];
}

const ::std::string&
BomberLoutreInterface::GameWaitRoom::ice_staticId()
{
    return __BomberLoutreInterface__GameWaitRoom_ids[0];
}

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::___newUserInRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    newUserInRoom(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::___userLeftRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    userLeftRoom(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::___allUsersReady(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    allUsersReady(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::___userReady(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string username;
    __is->read(username);
    __is->endReadEncaps();
    userReady(username, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::___gameDataUpdated(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::GameData g;
    g.__read(__is);
    __is->endReadEncaps();
    gameDataUpdated(g, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::___newMapDefined(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string map;
    __is->read(map);
    __is->endReadEncaps();
    newMapDefined(map, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::___gameStart(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    gameStart(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::___gameEnd(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    gameEnd(__current);
    return ::Ice::DispatchOK;
}

static ::std::string __BomberLoutreInterface__GameWaitRoom_all[] =
{
    "allUsersReady",
    "gameDataUpdated",
    "gameEnd",
    "gameStart",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "newMapDefined",
    "newUserInRoom",
    "userLeftRoom",
    "userReady"
};

::Ice::DispatchStatus
BomberLoutreInterface::GameWaitRoom::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__BomberLoutreInterface__GameWaitRoom_all, __BomberLoutreInterface__GameWaitRoom_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BomberLoutreInterface__GameWaitRoom_all)
    {
        case 0:
        {
            return ___allUsersReady(in, current);
        }
        case 1:
        {
            return ___gameDataUpdated(in, current);
        }
        case 2:
        {
            return ___gameEnd(in, current);
        }
        case 3:
        {
            return ___gameStart(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
        case 8:
        {
            return ___newMapDefined(in, current);
        }
        case 9:
        {
            return ___newUserInRoom(in, current);
        }
        case 10:
        {
            return ___userLeftRoom(in, current);
        }
        case 11:
        {
            return ___userReady(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BomberLoutreInterface::GameWaitRoom::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
BomberLoutreInterface::GameWaitRoom::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::GameWaitRoom::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::GameWaitRoom was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::GameWaitRoom::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::GameWaitRoom was not generated with stream support";
    throw ex;
}
#endif

void 
BomberLoutreInterface::__patch__GameWaitRoomPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::BomberLoutreInterface::GameWaitRoomPtr* p = static_cast< ::BomberLoutreInterface::GameWaitRoomPtr*>(__addr);
    assert(p);
    *p = ::BomberLoutreInterface::GameWaitRoomPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::BomberLoutreInterface::GameWaitRoom::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
BomberLoutreInterface::MapInterface::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __BomberLoutreInterface__MapInterface_ids[2] =
{
    "::BomberLoutreInterface::MapInterface",
    "::Ice::Object"
};

bool
BomberLoutreInterface::MapInterface::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BomberLoutreInterface__MapInterface_ids, __BomberLoutreInterface__MapInterface_ids + 2, _s);
}

::std::vector< ::std::string>
BomberLoutreInterface::MapInterface::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BomberLoutreInterface__MapInterface_ids[0], &__BomberLoutreInterface__MapInterface_ids[2]);
}

const ::std::string&
BomberLoutreInterface::MapInterface::ice_id(const ::Ice::Current&) const
{
    return __BomberLoutreInterface__MapInterface_ids[0];
}

const ::std::string&
BomberLoutreInterface::MapInterface::ice_staticId()
{
    return __BomberLoutreInterface__MapInterface_ids[0];
}

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::___getId(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::std::string __ret = getId(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::___getWidth(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getWidth(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::___getHeight(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::Ice::Int __ret = getHeight(__current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::___moveUp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Player p;
    p.__read(__is);
    __is->endReadEncaps();
    moveUp(p, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::___moveDown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Player p;
    p.__read(__is);
    __is->endReadEncaps();
    moveDown(p, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::___moveLeft(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Player p;
    p.__read(__is);
    __is->endReadEncaps();
    moveLeft(p, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::___moveRight(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Player p;
    p.__read(__is);
    __is->endReadEncaps();
    moveRight(p, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::___dropBomb(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Player p;
    ::BomberLoutreInterface::Bomb b;
    p.__read(__is);
    b.__read(__is);
    __is->endReadEncaps();
    dropBomb(p, b, __current);
    return ::Ice::DispatchOK;
}

static ::std::string __BomberLoutreInterface__MapInterface_all[] =
{
    "dropBomb",
    "getHeight",
    "getId",
    "getWidth",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "moveDown",
    "moveLeft",
    "moveRight",
    "moveUp"
};

::Ice::DispatchStatus
BomberLoutreInterface::MapInterface::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__BomberLoutreInterface__MapInterface_all, __BomberLoutreInterface__MapInterface_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BomberLoutreInterface__MapInterface_all)
    {
        case 0:
        {
            return ___dropBomb(in, current);
        }
        case 1:
        {
            return ___getHeight(in, current);
        }
        case 2:
        {
            return ___getId(in, current);
        }
        case 3:
        {
            return ___getWidth(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
        case 8:
        {
            return ___moveDown(in, current);
        }
        case 9:
        {
            return ___moveLeft(in, current);
        }
        case 10:
        {
            return ___moveRight(in, current);
        }
        case 11:
        {
            return ___moveUp(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BomberLoutreInterface::MapInterface::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
BomberLoutreInterface::MapInterface::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::MapInterface::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::MapInterface was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::MapInterface::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::MapInterface was not generated with stream support";
    throw ex;
}
#endif

void 
BomberLoutreInterface::__patch__MapInterfacePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::BomberLoutreInterface::MapInterfacePtr* p = static_cast< ::BomberLoutreInterface::MapInterfacePtr*>(__addr);
    assert(p);
    *p = ::BomberLoutreInterface::MapInterfacePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::BomberLoutreInterface::MapInterface::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
BomberLoutreInterface::MapObserver::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __BomberLoutreInterface__MapObserver_ids[2] =
{
    "::BomberLoutreInterface::MapObserver",
    "::Ice::Object"
};

bool
BomberLoutreInterface::MapObserver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BomberLoutreInterface__MapObserver_ids, __BomberLoutreInterface__MapObserver_ids + 2, _s);
}

::std::vector< ::std::string>
BomberLoutreInterface::MapObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BomberLoutreInterface__MapObserver_ids[0], &__BomberLoutreInterface__MapObserver_ids[2]);
}

const ::std::string&
BomberLoutreInterface::MapObserver::ice_id(const ::Ice::Current&) const
{
    return __BomberLoutreInterface__MapObserver_ids[0];
}

const ::std::string&
BomberLoutreInterface::MapObserver::ice_staticId()
{
    return __BomberLoutreInterface__MapObserver_ids[0];
}

::Ice::DispatchStatus
BomberLoutreInterface::MapObserver::___refreshMapItems(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::MapItems mi;
    ::BomberLoutreInterface::__readMapItems(__is, mi);
    __is->endReadEncaps();
    refreshMapItems(mi, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapObserver::___refreshPlayers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::PlayerList p;
    ::BomberLoutreInterface::__readPlayerList(__is, p);
    __is->endReadEncaps();
    refreshPlayers(p, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapObserver::___bombHasBeenPlanted(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Bomb b;
    b.__read(__is);
    __is->endReadEncaps();
    bombHasBeenPlanted(b, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapObserver::___bombExploded(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Bomb b;
    b.__read(__is);
    __is->endReadEncaps();
    bombExploded(b, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapObserver::___bombKicked(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Bomb b;
    ::BomberLoutreInterface::Point dest;
    b.__read(__is);
    dest.__read(__is);
    __is->endReadEncaps();
    bombKicked(b, dest, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapObserver::___bonusesDropped(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Bonuses b;
    ::BomberLoutreInterface::__readBonuses(__is, b);
    __is->endReadEncaps();
    bonusesDropped(b, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::MapObserver::___playerDied(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::BomberLoutreInterface::Player p;
    p.__read(__is);
    __is->endReadEncaps();
    playerDied(p, __current);
    return ::Ice::DispatchOK;
}

static ::std::string __BomberLoutreInterface__MapObserver_all[] =
{
    "bombExploded",
    "bombHasBeenPlanted",
    "bombKicked",
    "bonusesDropped",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "playerDied",
    "refreshMapItems",
    "refreshPlayers"
};

::Ice::DispatchStatus
BomberLoutreInterface::MapObserver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__BomberLoutreInterface__MapObserver_all, __BomberLoutreInterface__MapObserver_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BomberLoutreInterface__MapObserver_all)
    {
        case 0:
        {
            return ___bombExploded(in, current);
        }
        case 1:
        {
            return ___bombHasBeenPlanted(in, current);
        }
        case 2:
        {
            return ___bombKicked(in, current);
        }
        case 3:
        {
            return ___bonusesDropped(in, current);
        }
        case 4:
        {
            return ___ice_id(in, current);
        }
        case 5:
        {
            return ___ice_ids(in, current);
        }
        case 6:
        {
            return ___ice_isA(in, current);
        }
        case 7:
        {
            return ___ice_ping(in, current);
        }
        case 8:
        {
            return ___playerDied(in, current);
        }
        case 9:
        {
            return ___refreshMapItems(in, current);
        }
        case 10:
        {
            return ___refreshPlayers(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BomberLoutreInterface::MapObserver::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
BomberLoutreInterface::MapObserver::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::MapObserver::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::MapObserver was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::MapObserver::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::MapObserver was not generated with stream support";
    throw ex;
}
#endif

void 
BomberLoutreInterface::__patch__MapObserverPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::BomberLoutreInterface::MapObserverPtr* p = static_cast< ::BomberLoutreInterface::MapObserverPtr*>(__addr);
    assert(p);
    *p = ::BomberLoutreInterface::MapObserverPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::BomberLoutreInterface::MapObserver::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
BomberLoutreInterface::ServerInterface::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __BomberLoutreInterface__ServerInterface_ids[2] =
{
    "::BomberLoutreInterface::ServerInterface",
    "::Ice::Object"
};

bool
BomberLoutreInterface::ServerInterface::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BomberLoutreInterface__ServerInterface_ids, __BomberLoutreInterface__ServerInterface_ids + 2, _s);
}

::std::vector< ::std::string>
BomberLoutreInterface::ServerInterface::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BomberLoutreInterface__ServerInterface_ids[0], &__BomberLoutreInterface__ServerInterface_ids[2]);
}

const ::std::string&
BomberLoutreInterface::ServerInterface::ice_id(const ::Ice::Current&) const
{
    return __BomberLoutreInterface__ServerInterface_ids[0];
}

const ::std::string&
BomberLoutreInterface::ServerInterface::ice_staticId()
{
    return __BomberLoutreInterface__ServerInterface_ids[0];
}

::Ice::DispatchStatus
BomberLoutreInterface::ServerInterface::___connect(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string login;
    ::std::string password;
    __is->read(login);
    __is->read(password);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::BomberLoutreInterface::UserData __ret = connect(login, password, __current);
        __ret.__write(__os);
    }
    catch(const ::BomberLoutreInterface::BadLoginException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    catch(const ::BomberLoutreInterface::BadPasswordException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::ServerInterface::___createUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string login;
    ::std::string password;
    __is->read(login);
    __is->read(password);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::BomberLoutreInterface::UserData __ret = createUser(login, password, __current);
        __ret.__write(__os);
    }
    catch(const ::BomberLoutreInterface::UserAlreadyExistsException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::ServerInterface::___deleteUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string login;
    __is->read(login);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    bool __ret = deleteUser(login, __current);
    __os->write(__ret);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::ServerInterface::___addGame(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string name;
    ::BomberLoutreInterface::UserData user;
    ::BomberLoutreInterface::GameWaitRoomPrx room;
    ::BomberLoutreInterface::MapObserverPrx mo;
    __is->read(name);
    user.__read(__is);
    ::BomberLoutreInterface::__read(__is, room);
    ::BomberLoutreInterface::__read(__is, mo);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::BomberLoutreInterface::GameInterfacePrx __ret = addGame(name, user, room, mo, __current);
    __os->write(::Ice::ObjectPrx(::IceInternal::upCast(__ret.get())));
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::ServerInterface::___joinGame(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string name;
    ::BomberLoutreInterface::UserData user;
    ::BomberLoutreInterface::GameWaitRoomPrx room;
    ::BomberLoutreInterface::MapObserverPrx mo;
    __is->read(name);
    user.__read(__is);
    ::BomberLoutreInterface::__read(__is, room);
    ::BomberLoutreInterface::__read(__is, mo);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::BomberLoutreInterface::Map __ret = joinGame(name, user, room, mo, __current);
    __ret.__write(__os);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::ServerInterface::___getGameList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::BomberLoutreInterface::GameDataList __ret = getGameList(__current);
    if(__ret.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::BomberLoutreInterface::__writeGameDataList(__os, &__ret[0], &__ret[0] + __ret.size());
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BomberLoutreInterface::ServerInterface::___getUserList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    ::BomberLoutreInterface::UserDataList __ret = getUserList(__current);
    if(__ret.size() == 0)
    {
        __os->writeSize(0);
    }
    else
    {
        ::BomberLoutreInterface::__writeUserDataList(__os, &__ret[0], &__ret[0] + __ret.size());
    }
    return ::Ice::DispatchOK;
}

static ::std::string __BomberLoutreInterface__ServerInterface_all[] =
{
    "addGame",
    "connect",
    "createUser",
    "deleteUser",
    "getGameList",
    "getUserList",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "joinGame"
};

::Ice::DispatchStatus
BomberLoutreInterface::ServerInterface::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__BomberLoutreInterface__ServerInterface_all, __BomberLoutreInterface__ServerInterface_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BomberLoutreInterface__ServerInterface_all)
    {
        case 0:
        {
            return ___addGame(in, current);
        }
        case 1:
        {
            return ___connect(in, current);
        }
        case 2:
        {
            return ___createUser(in, current);
        }
        case 3:
        {
            return ___deleteUser(in, current);
        }
        case 4:
        {
            return ___getGameList(in, current);
        }
        case 5:
        {
            return ___getUserList(in, current);
        }
        case 6:
        {
            return ___ice_id(in, current);
        }
        case 7:
        {
            return ___ice_ids(in, current);
        }
        case 8:
        {
            return ___ice_isA(in, current);
        }
        case 9:
        {
            return ___ice_ping(in, current);
        }
        case 10:
        {
            return ___joinGame(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BomberLoutreInterface::ServerInterface::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
BomberLoutreInterface::ServerInterface::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
BomberLoutreInterface::ServerInterface::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::ServerInterface was not generated with stream support";
    throw ex;
}

void
BomberLoutreInterface::ServerInterface::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type BomberLoutreInterface::ServerInterface was not generated with stream support";
    throw ex;
}
#endif

void 
BomberLoutreInterface::__patch__ServerInterfacePtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::BomberLoutreInterface::ServerInterfacePtr* p = static_cast< ::BomberLoutreInterface::ServerInterfacePtr*>(__addr);
    assert(p);
    *p = ::BomberLoutreInterface::ServerInterfacePtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::BomberLoutreInterface::ServerInterface::ice_staticId(), v->ice_id());
    }
}
