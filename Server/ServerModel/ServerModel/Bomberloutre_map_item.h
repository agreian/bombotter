// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `Bomberloutre_map_item.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __C__Users_Simon_Desktop_bombotter_Server_ServerModel_ServerModel_Bomberloutre_map_item_h__
#define __C__Users_Simon_Desktop_bombotter_Server_ServerModel_ServerModel_Bomberloutre_map_item_h__

#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace BomberLoutreInterface
{

struct MapItem
{
    ::Ice::Int i;
    ::Ice::Int j;
    bool destructible;
    bool walkable;

    bool operator==(const MapItem& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        if(j != __rhs.j)
        {
            return false;
        }
        if(destructible != __rhs.destructible)
        {
            return false;
        }
        if(walkable != __rhs.walkable)
        {
            return false;
        }
        return true;
    }

    bool operator<(const MapItem& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        if(j < __rhs.j)
        {
            return true;
        }
        else if(__rhs.j < j)
        {
            return false;
        }
        if(destructible < __rhs.destructible)
        {
            return true;
        }
        else if(__rhs.destructible < destructible)
        {
            return false;
        }
        if(walkable < __rhs.walkable)
        {
            return true;
        }
        else if(__rhs.walkable < walkable)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const MapItem& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const MapItem& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const MapItem& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const MapItem& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::BomberLoutreInterface::MapItem> MapItems;
void __writeMapItems(::IceInternal::BasicStream*, const ::BomberLoutreInterface::MapItem*, const ::BomberLoutreInterface::MapItem*);
void __readMapItems(::IceInternal::BasicStream*, MapItems&);

struct Bomb
{
    ::Ice::Int i;
    ::Ice::Int j;
    ::Ice::Int power;
    ::Ice::Int timer;

    bool operator==(const Bomb& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        if(j != __rhs.j)
        {
            return false;
        }
        if(power != __rhs.power)
        {
            return false;
        }
        if(timer != __rhs.timer)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Bomb& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        if(j < __rhs.j)
        {
            return true;
        }
        else if(__rhs.j < j)
        {
            return false;
        }
        if(power < __rhs.power)
        {
            return true;
        }
        else if(__rhs.power < power)
        {
            return false;
        }
        if(timer < __rhs.timer)
        {
            return true;
        }
        else if(__rhs.timer < timer)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Bomb& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Bomb& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Bomb& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Bomb& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::BomberLoutreInterface::Bomb> Bombs;
void __writeBombs(::IceInternal::BasicStream*, const ::BomberLoutreInterface::Bomb*, const ::BomberLoutreInterface::Bomb*);
void __readBombs(::IceInternal::BasicStream*, Bombs&);

struct Bonus
{
    ::Ice::Int i;
    ::Ice::Int j;
    ::Ice::Int bomb;
    bool kick;
    ::Ice::Int power;
    ::Ice::Int speed;

    bool operator==(const Bonus& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(i != __rhs.i)
        {
            return false;
        }
        if(j != __rhs.j)
        {
            return false;
        }
        if(bomb != __rhs.bomb)
        {
            return false;
        }
        if(kick != __rhs.kick)
        {
            return false;
        }
        if(power != __rhs.power)
        {
            return false;
        }
        if(speed != __rhs.speed)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Bonus& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(i < __rhs.i)
        {
            return true;
        }
        else if(__rhs.i < i)
        {
            return false;
        }
        if(j < __rhs.j)
        {
            return true;
        }
        else if(__rhs.j < j)
        {
            return false;
        }
        if(bomb < __rhs.bomb)
        {
            return true;
        }
        else if(__rhs.bomb < bomb)
        {
            return false;
        }
        if(kick < __rhs.kick)
        {
            return true;
        }
        else if(__rhs.kick < kick)
        {
            return false;
        }
        if(power < __rhs.power)
        {
            return true;
        }
        else if(__rhs.power < power)
        {
            return false;
        }
        if(speed < __rhs.speed)
        {
            return true;
        }
        else if(__rhs.speed < speed)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Bonus& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Bonus& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Bonus& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Bonus& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::BomberLoutreInterface::Bonus> Bonuses;
void __writeBonuses(::IceInternal::BasicStream*, const ::BomberLoutreInterface::Bonus*, const ::BomberLoutreInterface::Bonus*);
void __readBonuses(::IceInternal::BasicStream*, Bonuses&);

}

#endif
